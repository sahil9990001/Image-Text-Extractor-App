define(['dart_sdk', 'packages/flutter/src/foundation/print.dart', 'packages/flutter/src/foundation/_platform_web.dart', 'packages/flutter/src/foundation/object.dart', 'packages/flutter/src/foundation/stack_frame.dart'], (function load__packages__flutter__src__foundation__debug_dart(dart_sdk, packages__flutter__src__foundation__print$46dart, packages__flutter__src__foundation___platform_web$46dart, packages__flutter__src__foundation__object$46dart, packages__flutter__src__foundation__stack_frame$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const async = dart_sdk.async;
  const _interceptors = dart_sdk._interceptors;
  const _internal = dart_sdk._internal;
  const _js_helper = dart_sdk._js_helper;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const print = packages__flutter__src__foundation__print$46dart.src__foundation__print;
  const platform = packages__flutter__src__foundation___platform_web$46dart.src__foundation__platform;
  const object$ = packages__flutter__src__foundation__object$46dart.src__foundation__object;
  const stack_frame = packages__flutter__src__foundation__stack_frame$46dart.src__foundation__stack_frame;
  var debug = Object.create(dart.library);
  var diagnostics$ = Object.create(dart.library);
  var assertions = Object.create(dart.library);
  var $toStringAsPrecision = dartx.toStringAsPrecision;
  var $toStringAsFixed = dartx.toStringAsFixed;
  var $times = dartx['*'];
  var $isEmpty = dartx.isEmpty;
  var $length = dartx.length;
  var $clear = dartx.clear;
  var $_get = dartx._get;
  var $substring = dartx.substring;
  var $split = dartx.split;
  var $isNotEmpty = dartx.isNotEmpty;
  var $last = dartx.last;
  var $add = dartx.add;
  var $trimRight = dartx.trimRight;
  var $endsWith = dartx.endsWith;
  var $toUpperCase = dartx.toUpperCase;
  var $contains = dartx.contains;
  var $where = dartx.where;
  var $take = dartx.take;
  var $toList = dartx.toList;
  var $first = dartx.first;
  var $_set = dartx._set;
  var $runtimeType = dartx.runtimeType;
  var $entries = dartx.entries;
  var $map = dartx.map;
  var $toString = dartx.toString;
  var $isFinite = dartx.isFinite;
  var $replaceAll = dartx.replaceAll;
  var $clamp = dartx.clamp;
  var $join = dartx.join;
  var $values = dartx.values;
  var $any = dartx.any;
  var $hashCode = dartx.hashCode;
  var $toUnsigned = dartx.toUnsigned;
  var $toRadixString = dartx.toRadixString;
  var $padLeft = dartx.padLeft;
  var $indexOf = dartx.indexOf;
  var $allMatches = dartx.allMatches;
  var $startsWith = dartx.startsWith;
  var $skip = dartx.skip;
  var $setRange = dartx.setRange;
  var $lastIndexOf = dartx.lastIndexOf;
  var $trimLeft = dartx.trimLeft;
  var $cast = dartx.cast;
  var $firstWhere = dartx.firstWhere;
  var $skipWhile = dartx.skipWhile;
  var $forEach = dartx.forEach;
  var $addAll = dartx.addAll;
  var $containsKey = dartx.containsKey;
  var $update = dartx.update;
  var $removeAt = dartx.removeAt;
  var $sort = dartx.sort;
  var $single = dartx.single;
  var $whereType = dartx.whereType;
  dart._checkModuleNullSafetyMode(false);
  var T$ = {
    StringN: () => (T$.StringN = dart.constFn(dart.nullable(core.String)))(),
    intN: () => (T$.intN = dart.constFn(dart.nullable(core.int)))(),
    StringN__Tovoid: () => (T$.StringN__Tovoid = dart.constFn(dart.fnType(dart.void, [T$.StringN()], {wrapWidth: T$.intN()}, {})))(),
    VoidTobool: () => (T$.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    StringL: () => (T$.StringL = dart.constFn(dart.legacy(core.String)))(),
    DiagnosticLevelL: () => (T$.DiagnosticLevelL = dart.constFn(dart.legacy(diagnostics$.DiagnosticLevel)))(),
    DiagnosticsTreeStyleL: () => (T$.DiagnosticsTreeStyleL = dart.constFn(dart.legacy(diagnostics$.DiagnosticsTreeStyle)))(),
    _WordWrapParseModeL: () => (T$._WordWrapParseModeL = dart.constFn(dart.legacy(diagnostics$._WordWrapParseMode)))(),
    JSArrayOfint: () => (T$.JSArrayOfint = dart.constFn(_interceptors.JSArray$(core.int)))(),
    VoidToint: () => (T$.VoidToint = dart.constFn(dart.fnType(core.int, [])))(),
    intTodynamic: () => (T$.intTodynamic = dart.constFn(dart.fnType(dart.dynamic, [core.int])))(),
    intTobool: () => (T$.intTobool = dart.constFn(dart.fnType(core.bool, [core.int])))(),
    SyncIterableOfString: () => (T$.SyncIterableOfString = dart.constFn(_js_helper.SyncIterable$(core.String)))(),
    JSArrayOfString: () => (T$.JSArrayOfString = dart.constFn(_interceptors.JSArray$(core.String)))(),
    DiagnosticsNodeTovoid: () => (T$.DiagnosticsNodeTovoid = dart.constFn(dart.fnType(dart.void, [diagnostics$.DiagnosticsNode])))(),
    DiagnosticsNodeTobool: () => (T$.DiagnosticsNodeTobool = dart.constFn(dart.fnType(core.bool, [diagnostics$.DiagnosticsNode])))(),
    DiagnosticsPropertyOfvoid: () => (T$.DiagnosticsPropertyOfvoid = dart.constFn(diagnostics$.DiagnosticsProperty$(dart.void)))(),
    ObjectN: () => (T$.ObjectN = dart.constFn(dart.nullable(core.Object)))(),
    IdentityMapOfString$ObjectN: () => (T$.IdentityMapOfString$ObjectN = dart.constFn(_js_helper.IdentityMap$(core.String, T$.ObjectN())))(),
    MapOfStringL$ObjectN: () => (T$.MapOfStringL$ObjectN = dart.constFn(core.Map$(T$.StringL(), T$.ObjectN())))(),
    MapLOfStringL$ObjectN: () => (T$.MapLOfStringL$ObjectN = dart.constFn(dart.legacy(T$.MapOfStringL$ObjectN())))(),
    MapOfString$ObjectN: () => (T$.MapOfString$ObjectN = dart.constFn(core.Map$(core.String, T$.ObjectN())))(),
    DiagnosticsNodeToMapOfString$ObjectN: () => (T$.DiagnosticsNodeToMapOfString$ObjectN = dart.constFn(dart.fnType(T$.MapOfString$ObjectN(), [diagnostics$.DiagnosticsNode])))(),
    DiagnosticsNodeL: () => (T$.DiagnosticsNodeL = dart.constFn(dart.legacy(diagnostics$.DiagnosticsNode)))(),
    DiagnosticableNodeOfDiagnosticable: () => (T$.DiagnosticableNodeOfDiagnosticable = dart.constFn(diagnostics$.DiagnosticableNode$(diagnostics$.Diagnosticable)))(),
    JSArrayOfDiagnosticsNode: () => (T$.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics$.DiagnosticsNode)))(),
    ListOfString: () => (T$.ListOfString = dart.constFn(core.List$(core.String)))(),
    JSArrayOfObject: () => (T$.JSArrayOfObject = dart.constFn(_interceptors.JSArray$(core.Object)))(),
    VoidToString: () => (T$.VoidToString = dart.constFn(dart.fnType(core.String, [])))(),
    DiagnosticsNodeN: () => (T$.DiagnosticsNodeN = dart.constFn(dart.nullable(diagnostics$.DiagnosticsNode)))(),
    DiagnosticsNodeNTobool: () => (T$.DiagnosticsNodeNTobool = dart.constFn(dart.fnType(core.bool, [T$.DiagnosticsNodeN()])))(),
    VoidToNull: () => (T$.VoidToNull = dart.constFn(dart.fnType(core.Null, [])))(),
    StackFrameTobool: () => (T$.StackFrameTobool = dart.constFn(dart.fnType(core.bool, [stack_frame.StackFrame])))(),
    IterableOfDiagnosticsNode: () => (T$.IterableOfDiagnosticsNode = dart.constFn(core.Iterable$(diagnostics$.DiagnosticsNode)))(),
    IterableOfDiagnosticsNodeToIterableOfDiagnosticsNode: () => (T$.IterableOfDiagnosticsNodeToIterableOfDiagnosticsNode = dart.constFn(dart.fnType(T$.IterableOfDiagnosticsNode(), [T$.IterableOfDiagnosticsNode()])))(),
    JSArrayOfIterableOfDiagnosticsNodeToIterableOfDiagnosticsNode: () => (T$.JSArrayOfIterableOfDiagnosticsNodeToIterableOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(T$.IterableOfDiagnosticsNodeToIterableOfDiagnosticsNode())))(),
    DiagnosticsPropertyOfFlutterError: () => (T$.DiagnosticsPropertyOfFlutterError = dart.constFn(diagnostics$.DiagnosticsProperty$(assertions.FlutterError)))(),
    DiagnosticsPropertyOfDiagnosticsNode: () => (T$.DiagnosticsPropertyOfDiagnosticsNode = dart.constFn(diagnostics$.DiagnosticsProperty$(diagnostics$.DiagnosticsNode)))(),
    StringToErrorDescription: () => (T$.StringToErrorDescription = dart.constFn(dart.fnType(assertions.ErrorDescription, [core.String])))(),
    IdentityMapOfString$int: () => (T$.IdentityMapOfString$int = dart.constFn(_js_helper.IdentityMap$(core.String, core.int)))(),
    intToint: () => (T$.intToint = dart.constFn(dart.fnType(core.int, [core.int])))(),
    ListOfStringN: () => (T$.ListOfStringN = dart.constFn(core.List$(T$.StringN())))(),
    DiagnosticsNodeToString: () => (T$.DiagnosticsNodeToString = dart.constFn(dart.fnType(core.String, [diagnostics$.DiagnosticsNode])))(),
    FlutterErrorDetailsTovoid: () => (T$.FlutterErrorDetailsTovoid = dart.constFn(dart.fnType(dart.void, [assertions.FlutterErrorDetails])))(),
    StackTraceToStackTrace: () => (T$.StackTraceToStackTrace = dart.constFn(dart.fnType(core.StackTrace, [core.StackTrace])))(),
    FlutterErrorDetails__Tovoid: () => (T$.FlutterErrorDetails__Tovoid = dart.constFn(dart.fnType(dart.void, [assertions.FlutterErrorDetails], {forceReport: core.bool}, {})))(),
    JSArrayOfStackFilter: () => (T$.JSArrayOfStackFilter = dart.constFn(_interceptors.JSArray$(assertions.StackFilter)))(),
    IterableOfString: () => (T$.IterableOfString = dart.constFn(core.Iterable$(core.String)))(),
    IterableOfStringToIterableOfString: () => (T$.IterableOfStringToIterableOfString = dart.constFn(dart.fnType(T$.IterableOfString(), [T$.IterableOfString()])))(),
    StringToDiagnosticsNode: () => (T$.StringToDiagnosticsNode = dart.constFn(dart.fnType(diagnostics$.DiagnosticsNode, [core.String])))(),
    StringTobool: () => (T$.StringTobool = dart.constFn(dart.fnType(core.bool, [core.String])))()
  };
  var T$Eval = Object.assign({
    _: () => T$Eval
  }, T$);
  var S = {
    _: () => S
  };
  var S$Eval = Object.assign({
    _: () => S$Eval
  }, S);
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.fn(print.debugPrintThrottled, T$.StringN__Tovoid());
    },
    get C1() {
      return C[1] = dart.constMap(T$.StringL(), T$.StringL(), ["mode", "basic"]);
    },
    get C2() {
      return C[2] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.hidden",
        index: 0
      });
    },
    get C3() {
      return C[3] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.fine",
        index: 1
      });
    },
    get C4() {
      return C[4] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.debug",
        index: 2
      });
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.info",
        index: 3
      });
    },
    get C6() {
      return C[6] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.warning",
        index: 4
      });
    },
    get C7() {
      return C[7] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.hint",
        index: 5
      });
    },
    get C8() {
      return C[8] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.summary",
        index: 6
      });
    },
    get C9() {
      return C[9] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.error",
        index: 7
      });
    },
    get C10() {
      return C[10] = dart.const({
        __proto__: diagnostics$.DiagnosticLevel.prototype,
        [_name$]: "DiagnosticLevel.off",
        index: 8
      });
    },
    get C11() {
      return C[11] = dart.constList([C[2] || CT.C2, C[3] || CT.C3, C[4] || CT.C4, C[5] || CT.C5, C[6] || CT.C6, C[7] || CT.C7, C[8] || CT.C8, C[9] || CT.C9, C[10] || CT.C10], T$.DiagnosticLevelL());
    },
    get C12() {
      return C[12] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.none",
        index: 0
      });
    },
    get C13() {
      return C[13] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.sparse",
        index: 1
      });
    },
    get C14() {
      return C[14] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.offstage",
        index: 2
      });
    },
    get C15() {
      return C[15] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.dense",
        index: 3
      });
    },
    get C16() {
      return C[16] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.transition",
        index: 4
      });
    },
    get C17() {
      return C[17] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.error",
        index: 5
      });
    },
    get C18() {
      return C[18] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.whitespace",
        index: 6
      });
    },
    get C19() {
      return C[19] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.flat",
        index: 7
      });
    },
    get C20() {
      return C[20] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.singleLine",
        index: 8
      });
    },
    get C21() {
      return C[21] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.errorProperty",
        index: 9
      });
    },
    get C22() {
      return C[22] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.shallow",
        index: 10
      });
    },
    get C23() {
      return C[23] = dart.const({
        __proto__: diagnostics$.DiagnosticsTreeStyle.prototype,
        [_name$]: "DiagnosticsTreeStyle.truncateChildren",
        index: 11
      });
    },
    get C24() {
      return C[24] = dart.constList([C[12] || CT.C12, C[13] || CT.C13, C[14] || CT.C14, C[15] || CT.C15, C[16] || CT.C16, C[17] || CT.C17, C[18] || CT.C18, C[19] || CT.C19, C[20] || CT.C20, C[21] || CT.C21, C[22] || CT.C22, C[23] || CT.C23], T$.DiagnosticsTreeStyleL());
    },
    get C25() {
      return C[25] = dart.const({
        __proto__: diagnostics$._WordWrapParseMode.prototype,
        [_name$]: "_WordWrapParseMode.inSpace",
        index: 0
      });
    },
    get C26() {
      return C[26] = dart.const({
        __proto__: diagnostics$._WordWrapParseMode.prototype,
        [_name$]: "_WordWrapParseMode.inWord",
        index: 1
      });
    },
    get C27() {
      return C[27] = dart.const({
        __proto__: diagnostics$._WordWrapParseMode.prototype,
        [_name$]: "_WordWrapParseMode.atBreak",
        index: 2
      });
    },
    get C28() {
      return C[28] = dart.constList([C[25] || CT.C25, C[26] || CT.C26, C[27] || CT.C27], T$._WordWrapParseModeL());
    },
    get C29() {
      return C[29] = dart.constList([], T$.MapLOfStringL$ObjectN());
    },
    get C30() {
      return C[30] = dart.const({
        __proto__: diagnostics$._NoDefaultValue.prototype
      });
    },
    get C31() {
      return C[31] = dart.constList([], T$.DiagnosticsNodeL());
    },
    get C32() {
      return C[32] = dart.constMap(T$.StringL(), T$.ObjectN(), []);
    },
    get C33() {
      return C[33] = dart.const({
        __proto__: assertions.PartialStackFrame.prototype,
        [method$]: "asynchronous suspension",
        [className$]: "",
        [$package$]: ""
      });
    },
    get C34() {
      return C[34] = dart.fn(assertions.FlutterError.dumpErrorToConsole, T$.FlutterErrorDetails__Tovoid());
    },
    get C35() {
      return C[35] = dart.fn(assertions.FlutterError.defaultStackFilter, T$.IterableOfStringToIterableOfString());
    },
    get C36() {
      return C[36] = dart.fn(assertions.DiagnosticsStackTrace._createStackFrame, T$.StringToDiagnosticsNode());
    }
  }, false);
  var C = Array(37).fill(void 0);
  var I = [
    "file:///C:/flutter/packages/flutter/lib/src/foundation/debug.dart",
    "file:///C:/flutter/packages/flutter/lib/src/foundation/diagnostics.dart",
    "package:flutter/src/foundation/diagnostics.dart",
    "file:///C:/flutter/packages/flutter/lib/src/foundation/assertions.dart",
    "package:flutter/src/foundation/assertions.dart"
  ];
  debug.debugAssertAllFoundationVarsUnset = function debugAssertAllFoundationVarsUnset(reason, opts) {
    if (reason == null) dart.nullFailed(I[0], 24, 47, "reason");
    let debugPrintOverride = opts && 'debugPrintOverride' in opts ? opts.debugPrintOverride : C[0] || CT.C0;
    if (debugPrintOverride == null) dart.nullFailed(I[0], 24, 76, "debugPrintOverride");
    if (!dart.test(dart.fn(() => {
      if (!dart.equals(print.debugPrint, debugPrintOverride) || platform.debugDefaultTargetPlatformOverride != null || debug.debugDoublePrecision != null || debug.debugBrightnessOverride != null) dart.throw(assertions.FlutterError.new(reason));
      return true;
    }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 25, 10, "() {\r\n    if (debugPrint != debugPrintOverride ||\r\n        debugDefaultTargetPlatformOverride != null ||\r\n        debugDoublePrecision != null ||\r\n        debugBrightnessOverride != null)\r\n      throw FlutterError(reason);\r\n    return true;\r\n  }()");
    return true;
  };
  debug.debugInstrumentAction = function debugInstrumentAction(T, description, action) {
    if (description == null) dart.nullFailed(I[0], 54, 43, "description");
    if (action == null) dart.nullFailed(I[0], 54, 66, "action");
    return async.async(T, function* debugInstrumentAction() {
      let t0;
      let instrument = false;
      if (!dart.test(dart.fn(() => {
        instrument = debug.debugInstrumentationEnabled;
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[0], 56, 10, "() {\r\n    instrument = debugInstrumentationEnabled;\r\n    return true;\r\n  }()");
      if (dart.test(instrument)) {
        let stopwatch = (t0 = new core.Stopwatch.new(), (() => {
          t0.start();
          return t0;
        })());
        try {
          return yield action();
        } finally {
          stopwatch.stop();
          print.debugPrint("Action \"" + dart.str(description) + "\" took " + dart.str(stopwatch.elapsed));
        }
      } else {
        return action();
      }
    });
  };
  debug.debugFormatDouble = function debugFormatDouble(value) {
    if (value == null) {
      return "null";
    }
    if (debug.debugDoublePrecision != null) {
      return value[$toStringAsPrecision](dart.nullCheck(debug.debugDoublePrecision));
    }
    return value[$toStringAsFixed](1);
  };
  dart.defineLazy(debug, {
    /*debug.debugInstrumentationEnabled*/get debugInstrumentationEnabled() {
      return false;
    },
    set debugInstrumentationEnabled(_) {},
    /*debug.timelineArgumentsIndicatingLandmarkEvent*/get timelineArgumentsIndicatingLandmarkEvent() {
      return C[1] || CT.C1;
    },
    /*debug.debugDoublePrecision*/get debugDoublePrecision() {
      return null;
    },
    set debugDoublePrecision(_) {},
    /*debug.debugBrightnessOverride*/get debugBrightnessOverride() {
      return null;
    },
    set debugBrightnessOverride(_) {},
    /*debug.activeDevToolsServerAddress*/get activeDevToolsServerAddress() {
      return null;
    },
    set activeDevToolsServerAddress(_) {},
    /*debug.connectedVmServiceUri*/get connectedVmServiceUri() {
      return null;
    },
    set connectedVmServiceUri(_) {}
  }, false);
  var _name$ = dart.privateName(diagnostics$, "_name");
  diagnostics$.DiagnosticLevel = class DiagnosticLevel extends core.Object {
    toString() {
      return this[_name$];
    }
  };
  (diagnostics$.DiagnosticLevel.new = function(index, _name) {
    if (index == null) dart.nullFailed(I[1], 28, 6, "index");
    if (_name == null) dart.nullFailed(I[1], 28, 6, "_name");
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = diagnostics$.DiagnosticLevel.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticLevel);
  dart.addTypeCaches(diagnostics$.DiagnosticLevel);
  dart.setLibraryUri(diagnostics$.DiagnosticLevel, I[2]);
  dart.setFieldSignature(diagnostics$.DiagnosticLevel, () => ({
    __proto__: dart.getFields(diagnostics$.DiagnosticLevel.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(diagnostics$.DiagnosticLevel, ['toString']);
  diagnostics$.DiagnosticLevel.hidden = C[2] || CT.C2;
  diagnostics$.DiagnosticLevel.fine = C[3] || CT.C3;
  diagnostics$.DiagnosticLevel.debug = C[4] || CT.C4;
  diagnostics$.DiagnosticLevel.info = C[5] || CT.C5;
  diagnostics$.DiagnosticLevel.warning = C[6] || CT.C6;
  diagnostics$.DiagnosticLevel.hint = C[7] || CT.C7;
  diagnostics$.DiagnosticLevel.summary = C[8] || CT.C8;
  diagnostics$.DiagnosticLevel.error = C[9] || CT.C9;
  diagnostics$.DiagnosticLevel.off = C[10] || CT.C10;
  diagnostics$.DiagnosticLevel.values = C[11] || CT.C11;
  diagnostics$.DiagnosticsTreeStyle = class DiagnosticsTreeStyle extends core.Object {
    toString() {
      return this[_name$];
    }
  };
  (diagnostics$.DiagnosticsTreeStyle.new = function(index, _name) {
    if (index == null) dart.nullFailed(I[1], 100, 6, "index");
    if (_name == null) dart.nullFailed(I[1], 100, 6, "_name");
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = diagnostics$.DiagnosticsTreeStyle.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticsTreeStyle);
  dart.addTypeCaches(diagnostics$.DiagnosticsTreeStyle);
  dart.setLibraryUri(diagnostics$.DiagnosticsTreeStyle, I[2]);
  dart.setFieldSignature(diagnostics$.DiagnosticsTreeStyle, () => ({
    __proto__: dart.getFields(diagnostics$.DiagnosticsTreeStyle.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(diagnostics$.DiagnosticsTreeStyle, ['toString']);
  diagnostics$.DiagnosticsTreeStyle.none = C[12] || CT.C12;
  diagnostics$.DiagnosticsTreeStyle.sparse = C[13] || CT.C13;
  diagnostics$.DiagnosticsTreeStyle.offstage = C[14] || CT.C14;
  diagnostics$.DiagnosticsTreeStyle.dense = C[15] || CT.C15;
  diagnostics$.DiagnosticsTreeStyle.transition = C[16] || CT.C16;
  diagnostics$.DiagnosticsTreeStyle.error = C[17] || CT.C17;
  diagnostics$.DiagnosticsTreeStyle.whitespace = C[18] || CT.C18;
  diagnostics$.DiagnosticsTreeStyle.flat = C[19] || CT.C19;
  diagnostics$.DiagnosticsTreeStyle.singleLine = C[20] || CT.C20;
  diagnostics$.DiagnosticsTreeStyle.errorProperty = C[21] || CT.C21;
  diagnostics$.DiagnosticsTreeStyle.shallow = C[22] || CT.C22;
  diagnostics$.DiagnosticsTreeStyle.truncateChildren = C[23] || CT.C23;
  diagnostics$.DiagnosticsTreeStyle.values = C[24] || CT.C24;
  var prefixLineOne$ = dart.privateName(diagnostics$, "TextTreeConfiguration.prefixLineOne");
  var suffixLineOne$ = dart.privateName(diagnostics$, "TextTreeConfiguration.suffixLineOne");
  var prefixOtherLines$ = dart.privateName(diagnostics$, "TextTreeConfiguration.prefixOtherLines");
  var prefixLastChildLineOne$ = dart.privateName(diagnostics$, "TextTreeConfiguration.prefixLastChildLineOne");
  var prefixOtherLinesRootNode$ = dart.privateName(diagnostics$, "TextTreeConfiguration.prefixOtherLinesRootNode");
  var propertyPrefixIfChildren$ = dart.privateName(diagnostics$, "TextTreeConfiguration.propertyPrefixIfChildren");
  var propertyPrefixNoChildren$ = dart.privateName(diagnostics$, "TextTreeConfiguration.propertyPrefixNoChildren");
  var linkCharacter$ = dart.privateName(diagnostics$, "TextTreeConfiguration.linkCharacter");
  var childLinkSpace = dart.privateName(diagnostics$, "TextTreeConfiguration.childLinkSpace");
  var lineBreak$ = dart.privateName(diagnostics$, "TextTreeConfiguration.lineBreak");
  var lineBreakProperties$ = dart.privateName(diagnostics$, "TextTreeConfiguration.lineBreakProperties");
  var beforeName$ = dart.privateName(diagnostics$, "TextTreeConfiguration.beforeName");
  var afterName$ = dart.privateName(diagnostics$, "TextTreeConfiguration.afterName");
  var afterDescriptionIfBody$ = dart.privateName(diagnostics$, "TextTreeConfiguration.afterDescriptionIfBody");
  var afterDescription$ = dart.privateName(diagnostics$, "TextTreeConfiguration.afterDescription");
  var beforeProperties$ = dart.privateName(diagnostics$, "TextTreeConfiguration.beforeProperties");
  var afterProperties$ = dart.privateName(diagnostics$, "TextTreeConfiguration.afterProperties");
  var mandatoryAfterProperties$ = dart.privateName(diagnostics$, "TextTreeConfiguration.mandatoryAfterProperties");
  var propertySeparator$ = dart.privateName(diagnostics$, "TextTreeConfiguration.propertySeparator");
  var bodyIndent$ = dart.privateName(diagnostics$, "TextTreeConfiguration.bodyIndent");
  var showChildren$ = dart.privateName(diagnostics$, "TextTreeConfiguration.showChildren");
  var addBlankLineIfNoChildren$ = dart.privateName(diagnostics$, "TextTreeConfiguration.addBlankLineIfNoChildren");
  var isNameOnOwnLine$ = dart.privateName(diagnostics$, "TextTreeConfiguration.isNameOnOwnLine");
  var footer$ = dart.privateName(diagnostics$, "TextTreeConfiguration.footer");
  var mandatoryFooter$ = dart.privateName(diagnostics$, "TextTreeConfiguration.mandatoryFooter");
  var isBlankLineBetweenPropertiesAndChildren$ = dart.privateName(diagnostics$, "TextTreeConfiguration.isBlankLineBetweenPropertiesAndChildren");
  diagnostics$.TextTreeConfiguration = class TextTreeConfiguration extends core.Object {
    get prefixLineOne() {
      return this[prefixLineOne$];
    }
    set prefixLineOne(value) {
      super.prefixLineOne = value;
    }
    get suffixLineOne() {
      return this[suffixLineOne$];
    }
    set suffixLineOne(value) {
      super.suffixLineOne = value;
    }
    get prefixOtherLines() {
      return this[prefixOtherLines$];
    }
    set prefixOtherLines(value) {
      super.prefixOtherLines = value;
    }
    get prefixLastChildLineOne() {
      return this[prefixLastChildLineOne$];
    }
    set prefixLastChildLineOne(value) {
      super.prefixLastChildLineOne = value;
    }
    get prefixOtherLinesRootNode() {
      return this[prefixOtherLinesRootNode$];
    }
    set prefixOtherLinesRootNode(value) {
      super.prefixOtherLinesRootNode = value;
    }
    get propertyPrefixIfChildren() {
      return this[propertyPrefixIfChildren$];
    }
    set propertyPrefixIfChildren(value) {
      super.propertyPrefixIfChildren = value;
    }
    get propertyPrefixNoChildren() {
      return this[propertyPrefixNoChildren$];
    }
    set propertyPrefixNoChildren(value) {
      super.propertyPrefixNoChildren = value;
    }
    get linkCharacter() {
      return this[linkCharacter$];
    }
    set linkCharacter(value) {
      super.linkCharacter = value;
    }
    get childLinkSpace() {
      return this[childLinkSpace];
    }
    set childLinkSpace(value) {
      super.childLinkSpace = value;
    }
    get lineBreak() {
      return this[lineBreak$];
    }
    set lineBreak(value) {
      super.lineBreak = value;
    }
    get lineBreakProperties() {
      return this[lineBreakProperties$];
    }
    set lineBreakProperties(value) {
      super.lineBreakProperties = value;
    }
    get beforeName() {
      return this[beforeName$];
    }
    set beforeName(value) {
      super.beforeName = value;
    }
    get afterName() {
      return this[afterName$];
    }
    set afterName(value) {
      super.afterName = value;
    }
    get afterDescriptionIfBody() {
      return this[afterDescriptionIfBody$];
    }
    set afterDescriptionIfBody(value) {
      super.afterDescriptionIfBody = value;
    }
    get afterDescription() {
      return this[afterDescription$];
    }
    set afterDescription(value) {
      super.afterDescription = value;
    }
    get beforeProperties() {
      return this[beforeProperties$];
    }
    set beforeProperties(value) {
      super.beforeProperties = value;
    }
    get afterProperties() {
      return this[afterProperties$];
    }
    set afterProperties(value) {
      super.afterProperties = value;
    }
    get mandatoryAfterProperties() {
      return this[mandatoryAfterProperties$];
    }
    set mandatoryAfterProperties(value) {
      super.mandatoryAfterProperties = value;
    }
    get propertySeparator() {
      return this[propertySeparator$];
    }
    set propertySeparator(value) {
      super.propertySeparator = value;
    }
    get bodyIndent() {
      return this[bodyIndent$];
    }
    set bodyIndent(value) {
      super.bodyIndent = value;
    }
    get showChildren() {
      return this[showChildren$];
    }
    set showChildren(value) {
      super.showChildren = value;
    }
    get addBlankLineIfNoChildren() {
      return this[addBlankLineIfNoChildren$];
    }
    set addBlankLineIfNoChildren(value) {
      super.addBlankLineIfNoChildren = value;
    }
    get isNameOnOwnLine() {
      return this[isNameOnOwnLine$];
    }
    set isNameOnOwnLine(value) {
      super.isNameOnOwnLine = value;
    }
    get footer() {
      return this[footer$];
    }
    set footer(value) {
      super.footer = value;
    }
    get mandatoryFooter() {
      return this[mandatoryFooter$];
    }
    set mandatoryFooter(value) {
      super.mandatoryFooter = value;
    }
    get isBlankLineBetweenPropertiesAndChildren() {
      return this[isBlankLineBetweenPropertiesAndChildren$];
    }
    set isBlankLineBetweenPropertiesAndChildren(value) {
      super.isBlankLineBetweenPropertiesAndChildren = value;
    }
  };
  (diagnostics$.TextTreeConfiguration.new = function(opts) {
    let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : null;
    if (prefixLineOne == null) dart.nullFailed(I[1], 204, 19, "prefixLineOne");
    let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
    if (prefixOtherLines == null) dart.nullFailed(I[1], 205, 19, "prefixOtherLines");
    let prefixLastChildLineOne = opts && 'prefixLastChildLineOne' in opts ? opts.prefixLastChildLineOne : null;
    if (prefixLastChildLineOne == null) dart.nullFailed(I[1], 206, 19, "prefixLastChildLineOne");
    let prefixOtherLinesRootNode = opts && 'prefixOtherLinesRootNode' in opts ? opts.prefixOtherLinesRootNode : null;
    if (prefixOtherLinesRootNode == null) dart.nullFailed(I[1], 207, 19, "prefixOtherLinesRootNode");
    let linkCharacter = opts && 'linkCharacter' in opts ? opts.linkCharacter : null;
    if (linkCharacter == null) dart.nullFailed(I[1], 208, 19, "linkCharacter");
    let propertyPrefixIfChildren = opts && 'propertyPrefixIfChildren' in opts ? opts.propertyPrefixIfChildren : null;
    if (propertyPrefixIfChildren == null) dart.nullFailed(I[1], 209, 19, "propertyPrefixIfChildren");
    let propertyPrefixNoChildren = opts && 'propertyPrefixNoChildren' in opts ? opts.propertyPrefixNoChildren : null;
    if (propertyPrefixNoChildren == null) dart.nullFailed(I[1], 210, 19, "propertyPrefixNoChildren");
    let lineBreak = opts && 'lineBreak' in opts ? opts.lineBreak : "\n";
    if (lineBreak == null) dart.nullFailed(I[1], 211, 10, "lineBreak");
    let lineBreakProperties = opts && 'lineBreakProperties' in opts ? opts.lineBreakProperties : true;
    if (lineBreakProperties == null) dart.nullFailed(I[1], 212, 10, "lineBreakProperties");
    let afterName = opts && 'afterName' in opts ? opts.afterName : ":";
    if (afterName == null) dart.nullFailed(I[1], 213, 10, "afterName");
    let afterDescriptionIfBody = opts && 'afterDescriptionIfBody' in opts ? opts.afterDescriptionIfBody : "";
    if (afterDescriptionIfBody == null) dart.nullFailed(I[1], 214, 10, "afterDescriptionIfBody");
    let afterDescription = opts && 'afterDescription' in opts ? opts.afterDescription : "";
    if (afterDescription == null) dart.nullFailed(I[1], 215, 10, "afterDescription");
    let beforeProperties = opts && 'beforeProperties' in opts ? opts.beforeProperties : "";
    if (beforeProperties == null) dart.nullFailed(I[1], 216, 10, "beforeProperties");
    let afterProperties = opts && 'afterProperties' in opts ? opts.afterProperties : "";
    if (afterProperties == null) dart.nullFailed(I[1], 217, 10, "afterProperties");
    let mandatoryAfterProperties = opts && 'mandatoryAfterProperties' in opts ? opts.mandatoryAfterProperties : "";
    if (mandatoryAfterProperties == null) dart.nullFailed(I[1], 218, 10, "mandatoryAfterProperties");
    let propertySeparator = opts && 'propertySeparator' in opts ? opts.propertySeparator : "";
    if (propertySeparator == null) dart.nullFailed(I[1], 219, 10, "propertySeparator");
    let bodyIndent = opts && 'bodyIndent' in opts ? opts.bodyIndent : "";
    if (bodyIndent == null) dart.nullFailed(I[1], 220, 10, "bodyIndent");
    let footer = opts && 'footer' in opts ? opts.footer : "";
    if (footer == null) dart.nullFailed(I[1], 221, 10, "footer");
    let showChildren = opts && 'showChildren' in opts ? opts.showChildren : true;
    if (showChildren == null) dart.nullFailed(I[1], 222, 10, "showChildren");
    let addBlankLineIfNoChildren = opts && 'addBlankLineIfNoChildren' in opts ? opts.addBlankLineIfNoChildren : true;
    if (addBlankLineIfNoChildren == null) dart.nullFailed(I[1], 223, 10, "addBlankLineIfNoChildren");
    let isNameOnOwnLine = opts && 'isNameOnOwnLine' in opts ? opts.isNameOnOwnLine : false;
    if (isNameOnOwnLine == null) dart.nullFailed(I[1], 224, 10, "isNameOnOwnLine");
    let isBlankLineBetweenPropertiesAndChildren = opts && 'isBlankLineBetweenPropertiesAndChildren' in opts ? opts.isBlankLineBetweenPropertiesAndChildren : true;
    if (isBlankLineBetweenPropertiesAndChildren == null) dart.nullFailed(I[1], 225, 10, "isBlankLineBetweenPropertiesAndChildren");
    let beforeName = opts && 'beforeName' in opts ? opts.beforeName : "";
    if (beforeName == null) dart.nullFailed(I[1], 226, 10, "beforeName");
    let suffixLineOne = opts && 'suffixLineOne' in opts ? opts.suffixLineOne : "";
    if (suffixLineOne == null) dart.nullFailed(I[1], 227, 10, "suffixLineOne");
    let mandatoryFooter = opts && 'mandatoryFooter' in opts ? opts.mandatoryFooter : "";
    if (mandatoryFooter == null) dart.nullFailed(I[1], 228, 10, "mandatoryFooter");
    this[prefixLineOne$] = prefixLineOne;
    this[prefixOtherLines$] = prefixOtherLines;
    this[prefixLastChildLineOne$] = prefixLastChildLineOne;
    this[prefixOtherLinesRootNode$] = prefixOtherLinesRootNode;
    this[linkCharacter$] = linkCharacter;
    this[propertyPrefixIfChildren$] = propertyPrefixIfChildren;
    this[propertyPrefixNoChildren$] = propertyPrefixNoChildren;
    this[lineBreak$] = lineBreak;
    this[lineBreakProperties$] = lineBreakProperties;
    this[afterName$] = afterName;
    this[afterDescriptionIfBody$] = afterDescriptionIfBody;
    this[afterDescription$] = afterDescription;
    this[beforeProperties$] = beforeProperties;
    this[afterProperties$] = afterProperties;
    this[mandatoryAfterProperties$] = mandatoryAfterProperties;
    this[propertySeparator$] = propertySeparator;
    this[bodyIndent$] = bodyIndent;
    this[footer$] = footer;
    this[showChildren$] = showChildren;
    this[addBlankLineIfNoChildren$] = addBlankLineIfNoChildren;
    this[isNameOnOwnLine$] = isNameOnOwnLine;
    this[isBlankLineBetweenPropertiesAndChildren$] = isBlankLineBetweenPropertiesAndChildren;
    this[beforeName$] = beforeName;
    this[suffixLineOne$] = suffixLineOne;
    this[mandatoryFooter$] = mandatoryFooter;
    if (!(prefixLineOne != null)) dart.assertFailed(null, I[1], 229, 15, "prefixLineOne != null");
    if (!(prefixOtherLines != null)) dart.assertFailed(null, I[1], 230, 15, "prefixOtherLines != null");
    if (!(prefixLastChildLineOne != null)) dart.assertFailed(null, I[1], 231, 15, "prefixLastChildLineOne != null");
    if (!(prefixOtherLinesRootNode != null)) dart.assertFailed(null, I[1], 232, 15, "prefixOtherLinesRootNode != null");
    if (!(linkCharacter != null)) dart.assertFailed(null, I[1], 233, 15, "linkCharacter != null");
    if (!(propertyPrefixIfChildren != null)) dart.assertFailed(null, I[1], 234, 15, "propertyPrefixIfChildren != null");
    if (!(propertyPrefixNoChildren != null)) dart.assertFailed(null, I[1], 235, 15, "propertyPrefixNoChildren != null");
    if (!(lineBreak != null)) dart.assertFailed(null, I[1], 236, 15, "lineBreak != null");
    if (!(lineBreakProperties != null)) dart.assertFailed(null, I[1], 237, 15, "lineBreakProperties != null");
    if (!(afterName != null)) dart.assertFailed(null, I[1], 238, 15, "afterName != null");
    if (!(afterDescriptionIfBody != null)) dart.assertFailed(null, I[1], 239, 15, "afterDescriptionIfBody != null");
    if (!(afterDescription != null)) dart.assertFailed(null, I[1], 240, 15, "afterDescription != null");
    if (!(beforeProperties != null)) dart.assertFailed(null, I[1], 241, 15, "beforeProperties != null");
    if (!(afterProperties != null)) dart.assertFailed(null, I[1], 242, 15, "afterProperties != null");
    if (!(propertySeparator != null)) dart.assertFailed(null, I[1], 243, 15, "propertySeparator != null");
    if (!(bodyIndent != null)) dart.assertFailed(null, I[1], 244, 15, "bodyIndent != null");
    if (!(footer != null)) dart.assertFailed(null, I[1], 245, 15, "footer != null");
    if (!(showChildren != null)) dart.assertFailed(null, I[1], 246, 15, "showChildren != null");
    if (!(addBlankLineIfNoChildren != null)) dart.assertFailed(null, I[1], 247, 15, "addBlankLineIfNoChildren != null");
    if (!(isNameOnOwnLine != null)) dart.assertFailed(null, I[1], 248, 15, "isNameOnOwnLine != null");
    if (!(isBlankLineBetweenPropertiesAndChildren != null)) dart.assertFailed(null, I[1], 249, 15, "isBlankLineBetweenPropertiesAndChildren != null");
    this[childLinkSpace] = " "[$times](linkCharacter.length);
    ;
  }).prototype = diagnostics$.TextTreeConfiguration.prototype;
  dart.addTypeTests(diagnostics$.TextTreeConfiguration);
  dart.addTypeCaches(diagnostics$.TextTreeConfiguration);
  dart.setLibraryUri(diagnostics$.TextTreeConfiguration, I[2]);
  dart.setFieldSignature(diagnostics$.TextTreeConfiguration, () => ({
    __proto__: dart.getFields(diagnostics$.TextTreeConfiguration.__proto__),
    prefixLineOne: dart.finalFieldType(core.String),
    suffixLineOne: dart.finalFieldType(core.String),
    prefixOtherLines: dart.finalFieldType(core.String),
    prefixLastChildLineOne: dart.finalFieldType(core.String),
    prefixOtherLinesRootNode: dart.finalFieldType(core.String),
    propertyPrefixIfChildren: dart.finalFieldType(core.String),
    propertyPrefixNoChildren: dart.finalFieldType(core.String),
    linkCharacter: dart.finalFieldType(core.String),
    childLinkSpace: dart.finalFieldType(core.String),
    lineBreak: dart.finalFieldType(core.String),
    lineBreakProperties: dart.finalFieldType(core.bool),
    beforeName: dart.finalFieldType(core.String),
    afterName: dart.finalFieldType(core.String),
    afterDescriptionIfBody: dart.finalFieldType(core.String),
    afterDescription: dart.finalFieldType(core.String),
    beforeProperties: dart.finalFieldType(core.String),
    afterProperties: dart.finalFieldType(core.String),
    mandatoryAfterProperties: dart.finalFieldType(core.String),
    propertySeparator: dart.finalFieldType(core.String),
    bodyIndent: dart.finalFieldType(core.String),
    showChildren: dart.finalFieldType(core.bool),
    addBlankLineIfNoChildren: dart.finalFieldType(core.bool),
    isNameOnOwnLine: dart.finalFieldType(core.bool),
    footer: dart.finalFieldType(core.String),
    mandatoryFooter: dart.finalFieldType(core.String),
    isBlankLineBetweenPropertiesAndChildren: dart.finalFieldType(core.bool)
  }));
  diagnostics$._WordWrapParseMode = class _WordWrapParseMode extends core.Object {
    toString() {
      return this[_name$];
    }
  };
  (diagnostics$._WordWrapParseMode.new = function(index, _name) {
    if (index == null) dart.nullFailed(I[1], 776, 6, "index");
    if (_name == null) dart.nullFailed(I[1], 776, 6, "_name");
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = diagnostics$._WordWrapParseMode.prototype;
  dart.addTypeTests(diagnostics$._WordWrapParseMode);
  dart.addTypeCaches(diagnostics$._WordWrapParseMode);
  dart.setLibraryUri(diagnostics$._WordWrapParseMode, I[2]);
  dart.setFieldSignature(diagnostics$._WordWrapParseMode, () => ({
    __proto__: dart.getFields(diagnostics$._WordWrapParseMode.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(diagnostics$._WordWrapParseMode, ['toString']);
  diagnostics$._WordWrapParseMode.inSpace = C[25] || CT.C25;
  diagnostics$._WordWrapParseMode.inWord = C[26] || CT.C26;
  diagnostics$._WordWrapParseMode.atBreak = C[27] || CT.C27;
  diagnostics$._WordWrapParseMode.values = C[28] || CT.C28;
  var _nextPrefixOtherLines = dart.privateName(diagnostics$, "_nextPrefixOtherLines");
  var _buffer = dart.privateName(diagnostics$, "_buffer");
  var _currentLine = dart.privateName(diagnostics$, "_currentLine");
  var _wrappableRanges = dart.privateName(diagnostics$, "_wrappableRanges");
  var _numLines = dart.privateName(diagnostics$, "_numLines");
  var _prefixOtherLines = dart.privateName(diagnostics$, "_prefixOtherLines");
  var _getCurrentPrefix = dart.privateName(diagnostics$, "_getCurrentPrefix");
  var _writeLine = dart.privateName(diagnostics$, "_writeLine");
  var _finalizeLine = dart.privateName(diagnostics$, "_finalizeLine");
  var _updatePrefix = dart.privateName(diagnostics$, "_updatePrefix");
  diagnostics$._PrefixedStringBuilder = class _PrefixedStringBuilder extends core.Object {
    get prefixOtherLines() {
      let t0;
      t0 = this[_nextPrefixOtherLines];
      return t0 == null ? this[_prefixOtherLines] : t0;
    }
    set prefixOtherLines(prefix) {
      this[_prefixOtherLines] = prefix;
      this[_nextPrefixOtherLines] = null;
    }
    incrementPrefixOtherLines(suffix, opts) {
      if (suffix == null) dart.nullFailed(I[1], 807, 41, "suffix");
      let updateCurrentLine = opts && 'updateCurrentLine' in opts ? opts.updateCurrentLine : null;
      if (updateCurrentLine == null) dart.nullFailed(I[1], 807, 64, "updateCurrentLine");
      if (dart.test(this[_currentLine].isEmpty) || dart.test(updateCurrentLine)) {
        this[_prefixOtherLines] = dart.nullCheck(this.prefixOtherLines) + dart.notNull(suffix);
        this[_nextPrefixOtherLines] = null;
      } else {
        this[_nextPrefixOtherLines] = dart.nullCheck(this.prefixOtherLines) + dart.notNull(suffix);
      }
    }
    get requiresMultipleLines() {
      return dart.notNull(this[_numLines]) > 1 || this[_numLines] === 1 && dart.test(this[_currentLine].isNotEmpty) || dart.notNull(this[_currentLine].length) + dart.nullCheck(this[_getCurrentPrefix](true)).length > dart.nullCheck(this.wrapWidth);
    }
    get isCurrentLineEmpty() {
      return this[_currentLine].isEmpty;
    }
    [_finalizeLine](addTrailingLineBreak) {
      if (addTrailingLineBreak == null) dart.nullFailed(I[1], 834, 27, "addTrailingLineBreak");
      let firstLine = this[_buffer].isEmpty;
      let text = dart.toString(this[_currentLine]);
      this[_currentLine].clear();
      if (dart.test(this[_wrappableRanges][$isEmpty])) {
        this[_writeLine](text, {includeLineBreak: addTrailingLineBreak, firstLine: firstLine});
        return;
      }
      let lines = diagnostics$._PrefixedStringBuilder._wordWrapLine(text, this[_wrappableRanges], dart.nullCheck(this.wrapWidth), {startOffset: dart.test(firstLine) ? this.prefixLineOne.length : dart.nullCheck(this[_prefixOtherLines]).length, otherLineOffset: dart.test(firstLine) ? dart.nullCheck(this[_prefixOtherLines]).length : dart.nullCheck(this[_prefixOtherLines]).length});
      let i = 0;
      let length = lines[$length];
      for (let line of lines) {
        i = i + 1;
        this[_writeLine](line, {includeLineBreak: dart.test(addTrailingLineBreak) || i < dart.notNull(length), firstLine: firstLine});
      }
      this[_wrappableRanges][$clear]();
    }
    static _wordWrapLine(message, wrapRanges, width, opts) {
      if (message == null) dart.nullFailed(I[1], 878, 48, "message");
      if (wrapRanges == null) dart.nullFailed(I[1], 878, 67, "wrapRanges");
      if (width == null) dart.nullFailed(I[1], 878, 83, "width");
      let startOffset = opts && 'startOffset' in opts ? opts.startOffset : 0;
      if (startOffset == null) dart.nullFailed(I[1], 878, 96, "startOffset");
      let otherLineOffset = opts && 'otherLineOffset' in opts ? opts.otherLineOffset : 0;
      if (otherLineOffset == null) dart.nullFailed(I[1], 878, 117, "otherLineOffset");
      return new (T$.SyncIterableOfString()).new(function* _wordWrapLine() {
        if (message.length + dart.notNull(startOffset) < dart.notNull(width)) {
          yield message;
          return;
        }
        let startForLengthCalculations = -dart.notNull(startOffset);
        let addPrefix = false;
        let index = 0;
        let mode = diagnostics$._WordWrapParseMode.inSpace;
        let lastWordStart = null;
        let lastWordStart$35isSet = false;
        function lastWordStart$35get() {
          return lastWordStart$35isSet ? lastWordStart : dart.throw(new _internal.LateError.localNI("lastWordStart"));
        }
        dart.fn(lastWordStart$35get, T$.VoidToint());
        function lastWordStart$35set(t3) {
          if (t3 == null) dart.nullFailed(I[1], 888, 14, "null");
          lastWordStart$35isSet = true;
          return lastWordStart = t3;
        }
        dart.fn(lastWordStart$35set, T$.intTodynamic());
        let lastWordEnd = null;
        let start = 0;
        let currentChunk = 0;
        function noWrap(index) {
          if (index == null) dart.nullFailed(I[1], 895, 21, "index");
          while (true) {
            if (currentChunk >= dart.notNull(wrapRanges[$length])) return true;
            if (dart.notNull(index) < dart.notNull(wrapRanges[$_get](currentChunk + 1))) break;
            currentChunk = currentChunk + 2;
          }
          return dart.notNull(index) < dart.notNull(wrapRanges[$_get](currentChunk));
        }
        dart.fn(noWrap, T$.intTobool());
        while (true) {
          switch (mode) {
            case C[25] || CT.C25:
            {
              while (index < message.length && message[$_get](index) === " ")
                index = index + 1;
              lastWordStart$35set(index);
              mode = diagnostics$._WordWrapParseMode.inWord;
              break;
            }
            case C[26] || CT.C26:
            {
              while (index < message.length && (message[$_get](index) !== " " || dart.test(noWrap(index))))
                index = index + 1;
              mode = diagnostics$._WordWrapParseMode.atBreak;
              break;
            }
            case C[27] || CT.C27:
            {
              if (index - startForLengthCalculations > dart.notNull(width) || index === message.length) {
                if (index - startForLengthCalculations <= dart.notNull(width) || lastWordEnd == null) {
                  lastWordEnd = index;
                }
                let line = message[$substring](start, lastWordEnd);
                yield line;
                addPrefix = true;
                if (dart.notNull(lastWordEnd) >= message.length) return;
                if (lastWordEnd === index) {
                  while (index < message.length && message[$_get](index) === " ")
                    index = index + 1;
                  start = index;
                  mode = diagnostics$._WordWrapParseMode.inWord;
                } else {
                  if (!(dart.notNull(lastWordStart$35get()) > dart.notNull(lastWordEnd))) dart.assertFailed(null, I[1], 943, 22, "lastWordStart > lastWordEnd");
                  start = lastWordStart$35get();
                  mode = diagnostics$._WordWrapParseMode.atBreak;
                }
                startForLengthCalculations = dart.notNull(start) - dart.notNull(otherLineOffset);
                if (!addPrefix) dart.assertFailed(null, I[1], 948, 20, "addPrefix");
                lastWordEnd = null;
              } else {
                lastWordEnd = index;
                mode = diagnostics$._WordWrapParseMode.inSpace;
              }
              break;
            }
            default:
            {
              dart.throw(new _internal.ReachabilityError.new("`null` encountered as case in a switch expression with a non-nullable enum type."));
            }
          }
        }
      });
    }
    write(s, opts) {
      let t5;
      if (s == null) dart.nullFailed(I[1], 966, 21, "s");
      let allowWrap = opts && 'allowWrap' in opts ? opts.allowWrap : false;
      if (allowWrap == null) dart.nullFailed(I[1], 966, 30, "allowWrap");
      if (s[$isEmpty]) return;
      let lines = s[$split]("\n");
      for (let i = 0; i < dart.notNull(lines[$length]); i = i + 1) {
        if (i > 0) {
          this[_finalizeLine](true);
          this[_updatePrefix]();
        }
        let line = lines[$_get](i);
        if (line[$isNotEmpty]) {
          if (dart.test(allowWrap) && this.wrapWidth != null) {
            let wrapStart = this[_currentLine].length;
            let wrapEnd = dart.notNull(wrapStart) + line.length;
            if (dart.test(this[_wrappableRanges][$isNotEmpty]) && this[_wrappableRanges][$last] == wrapStart) {
              this[_wrappableRanges][$last] = wrapEnd;
            } else {
              t5 = this[_wrappableRanges];
              (() => {
                t5[$add](wrapStart);
                t5[$add](wrapEnd);
                return t5;
              })();
            }
          }
          this[_currentLine].write(line);
        }
      }
    }
    [_updatePrefix]() {
      if (this[_nextPrefixOtherLines] != null) {
        this[_prefixOtherLines] = this[_nextPrefixOtherLines];
        this[_nextPrefixOtherLines] = null;
      }
    }
    [_writeLine](line, opts) {
      if (line == null) dart.nullFailed(I[1], 1000, 12, "line");
      let includeLineBreak = opts && 'includeLineBreak' in opts ? opts.includeLineBreak : null;
      if (includeLineBreak == null) dart.nullFailed(I[1], 1001, 19, "includeLineBreak");
      let firstLine = opts && 'firstLine' in opts ? opts.firstLine : null;
      if (firstLine == null) dart.nullFailed(I[1], 1002, 19, "firstLine");
      line = dart.str(this[_getCurrentPrefix](firstLine)) + dart.str(line);
      this[_buffer].write(line[$trimRight]());
      if (dart.test(includeLineBreak)) this[_buffer].write("\n");
      this[_numLines] = dart.notNull(this[_numLines]) + 1;
    }
    [_getCurrentPrefix](firstLine) {
      if (firstLine == null) dart.nullFailed(I[1], 1011, 34, "firstLine");
      return dart.test(this[_buffer].isEmpty) ? this.prefixLineOne : dart.test(firstLine) ? this[_prefixOtherLines] : this[_prefixOtherLines];
    }
    writeRawLines(lines) {
      if (lines == null) dart.nullFailed(I[1], 1017, 29, "lines");
      if (lines[$isEmpty]) return;
      if (dart.test(this[_currentLine].isNotEmpty)) {
        this[_finalizeLine](true);
      }
      if (!dart.test(this[_currentLine].isEmpty)) dart.assertFailed(null, I[1], 1024, 13, "_currentLine.isEmpty");
      this[_buffer].write(lines);
      if (!lines[$endsWith]("\n")) this[_buffer].write("\n");
      this[_numLines] = dart.notNull(this[_numLines]) + 1;
      this[_updatePrefix]();
    }
    writeStretched(text, targetLineLength) {
      if (text == null) dart.nullFailed(I[1], 1034, 30, "text");
      if (targetLineLength == null) dart.nullFailed(I[1], 1034, 40, "targetLineLength");
      this.write(text);
      let currentLineLength = dart.notNull(this[_currentLine].length) + dart.nullCheck(this[_getCurrentPrefix](this[_buffer].isEmpty)).length;
      if (!(dart.notNull(this[_currentLine].length) > 0)) dart.assertFailed(null, I[1], 1037, 13, "_currentLine.length > 0");
      let targetLength = dart.notNull(targetLineLength) - currentLineLength;
      if (targetLength > 0) {
        if (!text[$isNotEmpty]) dart.assertFailed(null, I[1], 1040, 14, "text.isNotEmpty");
        let lastChar = text[$_get](text.length - 1);
        if (!(lastChar !== "\n")) dart.assertFailed(null, I[1], 1042, 14, "lastChar != '\\n'");
        this[_currentLine].write(lastChar[$times](targetLength));
      }
      this[_wrappableRanges][$clear]();
    }
    build() {
      if (dart.test(this[_currentLine].isNotEmpty)) this[_finalizeLine](false);
      return dart.toString(this[_buffer]);
    }
  };
  (diagnostics$._PrefixedStringBuilder.new = function(opts) {
    let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : null;
    if (prefixLineOne == null) dart.nullFailed(I[1], 787, 19, "prefixLineOne");
    let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
    let wrapWidth = opts && 'wrapWidth' in opts ? opts.wrapWidth : null;
    this[_nextPrefixOtherLines] = null;
    this[_buffer] = new core.StringBuffer.new();
    this[_currentLine] = new core.StringBuffer.new();
    this[_wrappableRanges] = T$.JSArrayOfint().of([]);
    this[_numLines] = 0;
    this.prefixLineOne = prefixLineOne;
    this.wrapWidth = wrapWidth;
    this[_prefixOtherLines] = prefixOtherLines;
    ;
  }).prototype = diagnostics$._PrefixedStringBuilder.prototype;
  dart.addTypeTests(diagnostics$._PrefixedStringBuilder);
  dart.addTypeCaches(diagnostics$._PrefixedStringBuilder);
  dart.setMethodSignature(diagnostics$._PrefixedStringBuilder, () => ({
    __proto__: dart.getMethods(diagnostics$._PrefixedStringBuilder.__proto__),
    incrementPrefixOtherLines: dart.fnType(dart.void, [core.String], {}, {updateCurrentLine: core.bool}),
    [_finalizeLine]: dart.fnType(dart.void, [core.bool]),
    write: dart.fnType(dart.void, [core.String], {allowWrap: core.bool}, {}),
    [_updatePrefix]: dart.fnType(dart.void, []),
    [_writeLine]: dart.fnType(dart.void, [core.String], {}, {firstLine: core.bool, includeLineBreak: core.bool}),
    [_getCurrentPrefix]: dart.fnType(dart.nullable(core.String), [core.bool]),
    writeRawLines: dart.fnType(dart.void, [core.String]),
    writeStretched: dart.fnType(dart.void, [core.String, core.int]),
    build: dart.fnType(core.String, [])
  }));
  dart.setGetterSignature(diagnostics$._PrefixedStringBuilder, () => ({
    __proto__: dart.getGetters(diagnostics$._PrefixedStringBuilder.__proto__),
    prefixOtherLines: dart.nullable(core.String),
    requiresMultipleLines: core.bool,
    isCurrentLineEmpty: core.bool
  }));
  dart.setSetterSignature(diagnostics$._PrefixedStringBuilder, () => ({
    __proto__: dart.getSetters(diagnostics$._PrefixedStringBuilder.__proto__),
    prefixOtherLines: dart.nullable(core.String)
  }));
  dart.setLibraryUri(diagnostics$._PrefixedStringBuilder, I[2]);
  dart.setFieldSignature(diagnostics$._PrefixedStringBuilder, () => ({
    __proto__: dart.getFields(diagnostics$._PrefixedStringBuilder.__proto__),
    prefixLineOne: dart.finalFieldType(core.String),
    [_prefixOtherLines]: dart.fieldType(dart.nullable(core.String)),
    [_nextPrefixOtherLines]: dart.fieldType(dart.nullable(core.String)),
    wrapWidth: dart.finalFieldType(dart.nullable(core.int)),
    [_buffer]: dart.finalFieldType(core.StringBuffer),
    [_currentLine]: dart.finalFieldType(core.StringBuffer),
    [_wrappableRanges]: dart.finalFieldType(core.List$(core.int)),
    [_numLines]: dart.fieldType(core.int)
  }));
  diagnostics$._NoDefaultValue = class _NoDefaultValue extends core.Object {};
  (diagnostics$._NoDefaultValue.new = function() {
    ;
  }).prototype = diagnostics$._NoDefaultValue.prototype;
  dart.addTypeTests(diagnostics$._NoDefaultValue);
  dart.addTypeCaches(diagnostics$._NoDefaultValue);
  dart.setLibraryUri(diagnostics$._NoDefaultValue, I[2]);
  var _minLevel = dart.privateName(diagnostics$, "_minLevel");
  var _wrapWidth = dart.privateName(diagnostics$, "_wrapWidth");
  var _wrapWidthProperties = dart.privateName(diagnostics$, "_wrapWidthProperties");
  var _maxDescendentsTruncatableNode = dart.privateName(diagnostics$, "_maxDescendentsTruncatableNode");
  var _childTextConfiguration = dart.privateName(diagnostics$, "_childTextConfiguration");
  var _debugRender = dart.privateName(diagnostics$, "_debugRender");
  diagnostics$.TextTreeRenderer = class TextTreeRenderer extends core.Object {
    [_childTextConfiguration](child, textStyle) {
      if (child == null) dart.nullFailed(I[1], 1109, 21, "child");
      if (textStyle == null) dart.nullFailed(I[1], 1110, 27, "textStyle");
      let childStyle = child.style;
      return dart.test(diagnostics$._isSingleLine(childStyle)) || childStyle == diagnostics$.DiagnosticsTreeStyle.errorProperty ? textStyle : child.textTreeConfiguration;
    }
    render(node, opts) {
      if (node == null) dart.nullFailed(I[1], 1118, 21, "node");
      let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : "";
      if (prefixLineOne == null) dart.nullFailed(I[1], 1119, 12, "prefixLineOne");
      let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      if (false) {
        return "";
      } else {
        return this[_debugRender](node, {prefixLineOne: prefixLineOne, prefixOtherLines: prefixOtherLines, parentConfiguration: parentConfiguration});
      }
    }
    [_debugRender](node, opts) {
      let t5, t5$, t5$0;
      if (node == null) dart.nullFailed(I[1], 1135, 21, "node");
      let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : "";
      if (prefixLineOne == null) dart.nullFailed(I[1], 1136, 12, "prefixLineOne");
      let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      let isSingleLine = dart.test(diagnostics$._isSingleLine(node.style)) && (t5 = parentConfiguration, t5 == null ? null : t5.lineBreakProperties) !== true;
      prefixOtherLines == null ? prefixOtherLines = prefixLineOne : null;
      if (node.linePrefix != null) {
        prefixLineOne = dart.notNull(prefixLineOne) + dart.nullCheck(node.linePrefix);
        prefixOtherLines = dart.notNull(prefixOtherLines) + dart.nullCheck(node.linePrefix);
      }
      let config = dart.nullCheck(node.textTreeConfiguration);
      if (prefixOtherLines[$isEmpty]) prefixOtherLines = dart.notNull(prefixOtherLines) + dart.notNull(config.prefixOtherLinesRootNode);
      if (node.style == diagnostics$.DiagnosticsTreeStyle.truncateChildren) {
        let descendants = T$.JSArrayOfString().of([]);
        let depth = 0;
        let lines = 0;
        function visitor(node) {
          if (node == null) dart.nullFailed(I[1], 1159, 36, "node");
          for (let child of node.getChildren()) {
            if (lines < 25) {
              depth = depth + 1;
              descendants[$add](dart.str(prefixOtherLines) + "  "[$times](depth) + dart.str(child));
              if (depth < 5) visitor(child);
              depth = depth - 1;
            } else if (lines === 25) {
              descendants[$add](dart.str(prefixOtherLines) + "  ...(descendants list truncated after " + dart.str(lines) + " lines)");
            }
            lines = lines + 1;
          }
        }
        dart.fn(visitor, T$.DiagnosticsNodeTovoid());
        visitor(node);
        let information = new core.StringBuffer.new(prefixLineOne);
        if (lines > 1) {
          information.writeln("This " + dart.str(node.name) + " had the following descendants (showing up to depth " + dart.str(5) + "):");
        } else if (descendants[$length] === 1) {
          information.writeln("This " + dart.str(node.name) + " had the following child:");
        } else {
          information.writeln("This " + dart.str(node.name) + " has no descendants.");
        }
        information.writeAll(descendants, "\n");
        return information.toString();
      }
      let builder = new diagnostics$._PrefixedStringBuilder.new({prefixLineOne: prefixLineOne, prefixOtherLines: prefixOtherLines, wrapWidth: math.max(core.int, this[_wrapWidth], prefixOtherLines.length + dart.notNull(this[_wrapWidthProperties]))});
      let children = node.getChildren();
      let description = node.toDescription({parentConfiguration: parentConfiguration});
      if (config.beforeName[$isNotEmpty]) {
        builder.write(config.beforeName);
      }
      let wrapName = !isSingleLine && dart.test(node.allowNameWrap);
      let wrapDescription = !isSingleLine && dart.test(node.allowWrap);
      let uppercaseTitle = node.style == diagnostics$.DiagnosticsTreeStyle.error;
      let name = node.name;
      if (uppercaseTitle) {
        name = (t5$ = name, t5$ == null ? null : t5$[$toUpperCase]());
      }
      if (description == null || description[$isEmpty]) {
        if (dart.test(node.showName) && name != null) builder.write(name, {allowWrap: wrapName});
      } else {
        let includeName = false;
        if (name != null && name[$isNotEmpty] && dart.test(node.showName)) {
          includeName = true;
          builder.write(name, {allowWrap: wrapName});
          if (dart.test(node.showSeparator)) builder.write(config.afterName, {allowWrap: wrapName});
          builder.write(dart.test(config.isNameOnOwnLine) || description[$contains]("\n") ? "\n" : " ", {allowWrap: wrapName});
        }
        if (!isSingleLine && dart.test(builder.requiresMultipleLines) && !dart.test(builder.isCurrentLineEmpty)) {
          builder.write("\n");
        }
        if (includeName) {
          builder.incrementPrefixOtherLines(dart.test(children[$isEmpty]) ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren, {updateCurrentLine: true});
        }
        if (uppercaseTitle) {
          description = description[$toUpperCase]();
        }
        builder.write(description[$trimRight](), {allowWrap: wrapDescription});
        if (!includeName) {
          builder.incrementPrefixOtherLines(dart.test(children[$isEmpty]) ? config.propertyPrefixNoChildren : config.propertyPrefixIfChildren, {updateCurrentLine: false});
        }
      }
      if (config.suffixLineOne[$isNotEmpty]) {
        builder.writeStretched(config.suffixLineOne, dart.nullCheck(builder.wrapWidth));
      }
      let propertiesIterable = node.getProperties()[$where](dart.fn(n => {
        if (n == null) dart.nullFailed(I[1], 1249, 30, "n");
        return !dart.test(n.isFiltered(this[_minLevel]));
      }, T$.DiagnosticsNodeTobool()));
      let properties = null;
      if (dart.notNull(this[_maxDescendentsTruncatableNode]) >= 0 && dart.test(node.allowTruncate)) {
        if (dart.notNull(propertiesIterable[$length]) < dart.notNull(this[_maxDescendentsTruncatableNode])) {
          properties = propertiesIterable[$take](this[_maxDescendentsTruncatableNode])[$toList]();
          properties[$add](diagnostics$.DiagnosticsNode.message("..."));
        } else {
          properties = propertiesIterable[$toList]();
        }
        if (dart.notNull(this[_maxDescendentsTruncatableNode]) < dart.notNull(children[$length])) {
          children = children[$take](this[_maxDescendentsTruncatableNode])[$toList]();
          children[$add](diagnostics$.DiagnosticsNode.message("..."));
        }
      } else {
        properties = propertiesIterable[$toList]();
      }
      if ((dart.test(properties[$isNotEmpty]) || dart.test(children[$isNotEmpty]) || node.emptyBodyDescription != null) && (dart.test(node.showSeparator) || (t5$0 = description, t5$0 == null ? null : t5$0[$isNotEmpty]) === true)) {
        builder.write(config.afterDescriptionIfBody);
      }
      if (dart.test(config.lineBreakProperties)) builder.write(config.lineBreak);
      if (dart.test(properties[$isNotEmpty])) builder.write(config.beforeProperties);
      builder.incrementPrefixOtherLines(config.bodyIndent, {updateCurrentLine: false});
      if (node.emptyBodyDescription != null && dart.test(properties[$isEmpty]) && dart.test(children[$isEmpty]) && prefixLineOne[$isNotEmpty]) {
        builder.write(dart.nullCheck(node.emptyBodyDescription));
        if (dart.test(config.lineBreakProperties)) builder.write(config.lineBreak);
      }
      for (let i = 0; i < dart.notNull(properties[$length]); i = i + 1) {
        let property = properties[$_get](i);
        if (i > 0) builder.write(config.propertySeparator);
        let propertyStyle = dart.nullCheck(property.textTreeConfiguration);
        if (dart.test(diagnostics$._isSingleLine(property.style))) {
          let propertyRender = this.render(property, {prefixLineOne: propertyStyle.prefixLineOne, prefixOtherLines: dart.str(propertyStyle.childLinkSpace) + dart.str(propertyStyle.prefixOtherLines), parentConfiguration: config});
          let propertyLines = propertyRender[$split]("\n");
          if (propertyLines[$length] === 1 && !dart.test(config.lineBreakProperties)) {
            builder.write(propertyLines[$first]);
          } else {
            builder.write(propertyRender, {allowWrap: false});
            if (!propertyRender[$endsWith]("\n")) builder.write("\n");
          }
        } else {
          let propertyRender = this.render(property, {prefixLineOne: dart.str(builder.prefixOtherLines) + dart.str(propertyStyle.prefixLineOne), prefixOtherLines: dart.str(builder.prefixOtherLines) + dart.str(propertyStyle.childLinkSpace) + dart.str(propertyStyle.prefixOtherLines), parentConfiguration: config});
          builder.writeRawLines(propertyRender);
        }
      }
      if (dart.test(properties[$isNotEmpty])) builder.write(config.afterProperties);
      builder.write(config.mandatoryAfterProperties);
      if (!dart.test(config.lineBreakProperties)) builder.write(config.lineBreak);
      let prefixChildren = config.bodyIndent;
      let prefixChildrenRaw = dart.str(prefixOtherLines) + dart.str(prefixChildren);
      if (dart.test(children[$isEmpty]) && dart.test(config.addBlankLineIfNoChildren) && dart.test(builder.requiresMultipleLines) && dart.nullCheck(builder.prefixOtherLines)[$trimRight]()[$isNotEmpty]) {
        builder.write(config.lineBreak);
      }
      if (dart.test(children[$isNotEmpty]) && dart.test(config.showChildren)) {
        if (dart.test(config.isBlankLineBetweenPropertiesAndChildren) && dart.test(properties[$isNotEmpty]) && dart.test(dart.nullCheck(children[$first].textTreeConfiguration).isBlankLineBetweenPropertiesAndChildren)) {
          builder.write(config.lineBreak);
        }
        builder.prefixOtherLines = prefixOtherLines;
        for (let i = 0; i < dart.notNull(children[$length]); i = i + 1) {
          let child = children[$_get](i);
          if (!(child != null)) dart.assertFailed(null, I[1], 1354, 16, "child != null");
          let childConfig = dart.nullCheck(this[_childTextConfiguration](child, config));
          if (i === dart.notNull(children[$length]) - 1) {
            let lastChildPrefixLineOne = prefixChildrenRaw + dart.str(childConfig.prefixLastChildLineOne);
            let childPrefixOtherLines = prefixChildrenRaw + dart.str(childConfig.childLinkSpace) + dart.str(childConfig.prefixOtherLines);
            builder.writeRawLines(this.render(child, {prefixLineOne: lastChildPrefixLineOne, prefixOtherLines: childPrefixOtherLines, parentConfiguration: config}));
            if (childConfig.footer[$isNotEmpty]) {
              builder.prefixOtherLines = prefixChildrenRaw;
              builder.write(dart.str(childConfig.childLinkSpace) + dart.str(childConfig.footer));
              if (childConfig.mandatoryFooter[$isNotEmpty]) {
                builder.writeStretched(childConfig.mandatoryFooter, math.max(core.int, dart.nullCheck(builder.wrapWidth), dart.notNull(this[_wrapWidthProperties]) + childPrefixOtherLines.length));
              }
              builder.write(config.lineBreak);
            }
          } else {
            let nextChildStyle = dart.nullCheck(this[_childTextConfiguration](children[$_get](i + 1), config));
            let childPrefixLineOne = prefixChildrenRaw + dart.str(childConfig.prefixLineOne);
            let childPrefixOtherLines = prefixChildrenRaw + dart.str(nextChildStyle.linkCharacter) + dart.str(childConfig.prefixOtherLines);
            builder.writeRawLines(this.render(child, {prefixLineOne: childPrefixLineOne, prefixOtherLines: childPrefixOtherLines, parentConfiguration: config}));
            if (childConfig.footer[$isNotEmpty]) {
              builder.prefixOtherLines = prefixChildrenRaw;
              builder.write(dart.str(childConfig.linkCharacter) + dart.str(childConfig.footer));
              if (childConfig.mandatoryFooter[$isNotEmpty]) {
                builder.writeStretched(childConfig.mandatoryFooter, math.max(core.int, dart.nullCheck(builder.wrapWidth), dart.notNull(this[_wrapWidthProperties]) + childPrefixOtherLines.length));
              }
              builder.write(config.lineBreak);
            }
          }
        }
      }
      if (parentConfiguration == null && config.mandatoryFooter[$isNotEmpty]) {
        builder.writeStretched(config.mandatoryFooter, dart.nullCheck(builder.wrapWidth));
        builder.write(config.lineBreak);
      }
      return builder.build();
    }
  };
  (diagnostics$.TextTreeRenderer.new = function(opts) {
    let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[4] || CT.C4;
    if (minLevel == null) dart.nullFailed(I[1], 1087, 21, "minLevel");
    let wrapWidth = opts && 'wrapWidth' in opts ? opts.wrapWidth : 100;
    if (wrapWidth == null) dart.nullFailed(I[1], 1088, 9, "wrapWidth");
    let wrapWidthProperties = opts && 'wrapWidthProperties' in opts ? opts.wrapWidthProperties : 65;
    if (wrapWidthProperties == null) dart.nullFailed(I[1], 1089, 9, "wrapWidthProperties");
    let maxDescendentsTruncatableNode = opts && 'maxDescendentsTruncatableNode' in opts ? opts.maxDescendentsTruncatableNode : -1;
    if (maxDescendentsTruncatableNode == null) dart.nullFailed(I[1], 1090, 9, "maxDescendentsTruncatableNode");
    if (!(minLevel != null)) dart.assertFailed(null, I[1], 1091, 15, "minLevel != null");
    this[_minLevel] = minLevel;
    this[_wrapWidth] = wrapWidth;
    this[_wrapWidthProperties] = wrapWidthProperties;
    this[_maxDescendentsTruncatableNode] = maxDescendentsTruncatableNode;
    ;
  }).prototype = diagnostics$.TextTreeRenderer.prototype;
  dart.addTypeTests(diagnostics$.TextTreeRenderer);
  dart.addTypeCaches(diagnostics$.TextTreeRenderer);
  dart.setMethodSignature(diagnostics$.TextTreeRenderer, () => ({
    __proto__: dart.getMethods(diagnostics$.TextTreeRenderer.__proto__),
    [_childTextConfiguration]: dart.fnType(dart.nullable(diagnostics$.TextTreeConfiguration), [diagnostics$.DiagnosticsNode, diagnostics$.TextTreeConfiguration]),
    render: dart.fnType(core.String, [diagnostics$.DiagnosticsNode], {parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration), prefixLineOne: core.String, prefixOtherLines: dart.nullable(core.String)}, {}),
    [_debugRender]: dart.fnType(core.String, [diagnostics$.DiagnosticsNode], {parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration), prefixLineOne: core.String, prefixOtherLines: dart.nullable(core.String)}, {})
  }));
  dart.setLibraryUri(diagnostics$.TextTreeRenderer, I[2]);
  dart.setFieldSignature(diagnostics$.TextTreeRenderer, () => ({
    __proto__: dart.getFields(diagnostics$.TextTreeRenderer.__proto__),
    [_wrapWidth]: dart.finalFieldType(core.int),
    [_wrapWidthProperties]: dart.finalFieldType(core.int),
    [_minLevel]: dart.finalFieldType(diagnostics$.DiagnosticLevel),
    [_maxDescendentsTruncatableNode]: dart.finalFieldType(core.int)
  }));
  var name$ = dart.privateName(diagnostics$, "DiagnosticsNode.name");
  var showSeparator$ = dart.privateName(diagnostics$, "DiagnosticsNode.showSeparator");
  var showName$ = dart.privateName(diagnostics$, "DiagnosticsNode.showName");
  var linePrefix$ = dart.privateName(diagnostics$, "DiagnosticsNode.linePrefix");
  var style$ = dart.privateName(diagnostics$, "DiagnosticsNode.style");
  var _separator = dart.privateName(diagnostics$, "_separator");
  diagnostics$.DiagnosticsNode = class DiagnosticsNode extends core.Object {
    get name() {
      return this[name$];
    }
    set name(value) {
      super.name = value;
    }
    get showSeparator() {
      return this[showSeparator$];
    }
    set showSeparator(value) {
      super.showSeparator = value;
    }
    get showName() {
      return this[showName$];
    }
    set showName(value) {
      super.showName = value;
    }
    get linePrefix() {
      return this[linePrefix$];
    }
    set linePrefix(value) {
      super.linePrefix = value;
    }
    get style() {
      return this[style$];
    }
    set style(value) {
      super.style = value;
    }
    static message(message, opts) {
      if (message == null) dart.nullFailed(I[1], 1451, 12, "message");
      let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
      if (style == null) dart.nullFailed(I[1], 1452, 26, "style");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 1453, 21, "level");
      let allowWrap = opts && 'allowWrap' in opts ? opts.allowWrap : true;
      if (allowWrap == null) dart.nullFailed(I[1], 1454, 10, "allowWrap");
      if (!(style != null)) dart.assertFailed(null, I[1], 1456, 12, "style != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 1457, 12, "level != null");
      return new (T$.DiagnosticsPropertyOfvoid()).new("", null, {description: message, style: style, showName: false, allowWrap: allowWrap, level: level});
    }
    isFiltered(minLevel) {
      if (minLevel == null) dart.nullFailed(I[1], 1494, 35, "minLevel");
      return false || dart.notNull(this.level.index) < dart.notNull(minLevel.index);
    }
    get level() {
      return false ? diagnostics$.DiagnosticLevel.hidden : diagnostics$.DiagnosticLevel.info;
    }
    get emptyBodyDescription() {
      return null;
    }
    get allowWrap() {
      return false;
    }
    get allowNameWrap() {
      return false;
    }
    get allowTruncate() {
      return false;
    }
    get [_separator]() {
      return dart.test(this.showSeparator) ? ":" : "";
    }
    toJsonMap(delegate) {
      if (delegate == null) dart.nullFailed(I[1], 1563, 67, "delegate");
      let result = new (T$.IdentityMapOfString$ObjectN()).new();
      if (!dart.test(dart.fn(() => {
        let t6;
        let hasChildren = this.getChildren()[$isNotEmpty];
        result = (() => {
          let t5 = new (T$.IdentityMapOfString$ObjectN()).new();
          t5[$_set]("description", this.toDescription());
          t5[$_set]("type", dart.toString(this[$runtimeType]));
          if (this.name != null) t5[$_set]("name", this.name);
          if (!dart.test(this.showSeparator)) t5[$_set]("showSeparator", this.showSeparator);
          if (this.level != diagnostics$.DiagnosticLevel.info) t5[$_set]("level", diagnostics$.describeEnum(this.level));
          if (this.showName === false) t5[$_set]("showName", this.showName);
          if (this.emptyBodyDescription != null) t5[$_set]("emptyBodyDescription", this.emptyBodyDescription);
          if (this.style != diagnostics$.DiagnosticsTreeStyle.sparse) t5[$_set]("style", diagnostics$.describeEnum(dart.nullCheck(this.style)));
          if (dart.test(this.allowTruncate)) t5[$_set]("allowTruncate", this.allowTruncate);
          if (dart.test(hasChildren)) t5[$_set]("hasChildren", hasChildren);
          if ((t6 = this.linePrefix, t6 == null ? null : t6[$isNotEmpty]) === true) t5[$_set]("linePrefix", this.linePrefix);
          if (!dart.test(this.allowWrap)) t5[$_set]("allowWrap", this.allowWrap);
          if (dart.test(this.allowNameWrap)) t5[$_set]("allowNameWrap", this.allowNameWrap);
          for (let t6$ of delegate.additionalNodeProperties(this)[$entries])
            t5[$_set](t6$.key, t6$.value);
          if (dart.test(delegate.includeProperties)) t5[$_set]("properties", diagnostics$.DiagnosticsNode.toJsonList(delegate.filterProperties(this.getProperties(), this), this, delegate));
          if (dart.notNull(delegate.subtreeDepth) > 0) t5[$_set]("children", diagnostics$.DiagnosticsNode.toJsonList(delegate.filterChildren(this.getChildren(), this), this, delegate));
          return t5;
        })();
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 1565, 12, "() {\r\n      final bool hasChildren = getChildren().isNotEmpty;\r\n      result = <String, Object?>{\r\n        'description': toDescription(),\r\n        'type': runtimeType.toString(),\r\n        if (name != null)\r\n          'name': name,\r\n        if (!showSeparator)\r\n          'showSeparator': showSeparator,\r\n        if (level != DiagnosticLevel.info)\r\n          'level': describeEnum(level),\r\n        if (showName == false)\r\n          'showName': showName,\r\n        if (emptyBodyDescription != null)\r\n          'emptyBodyDescription': emptyBodyDescription,\r\n        if (style != DiagnosticsTreeStyle.sparse)\r\n          'style': describeEnum(style!),\r\n        if (allowTruncate)\r\n          'allowTruncate': allowTruncate,\r\n        if (hasChildren)\r\n          'hasChildren': hasChildren,\r\n        if (linePrefix?.isNotEmpty == true)\r\n          'linePrefix': linePrefix,\r\n        if (!allowWrap)\r\n          'allowWrap': allowWrap,\r\n        if (allowNameWrap)\r\n          'allowNameWrap': allowNameWrap,\r\n        ...delegate.additionalNodeProperties(this),\r\n        if (delegate.includeProperties)\r\n          'properties': toJsonList(\r\n            delegate.filterProperties(getProperties(), this),\r\n            this,\r\n            delegate,\r\n          ),\r\n        if (delegate.subtreeDepth > 0)\r\n          'children': toJsonList(\r\n            delegate.filterChildren(getChildren(), this),\r\n            this,\r\n            delegate,\r\n          ),\r\n      };\r\n      return true;\r\n    }()");
      return result;
    }
    static toJsonList(nodes, parent, delegate) {
      if (delegate == null) dart.nullFailed(I[1], 1619, 38, "delegate");
      let truncated = false;
      if (nodes == null) return C[29] || CT.C29;
      let originalNodeCount = nodes[$length];
      nodes = delegate.truncateNodesList(nodes, parent);
      if (nodes[$length] != originalNodeCount) {
        nodes[$add](diagnostics$.DiagnosticsNode.message("..."));
        truncated = true;
      }
      let json = nodes[$map](T$.MapOfString$ObjectN(), dart.fn(node => {
        if (node == null) dart.nullFailed(I[1], 1630, 94, "node");
        return node.toJsonMap(delegate.delegateForNode(node));
      }, T$.DiagnosticsNodeToMapOfString$ObjectN()))[$toList]();
      if (truncated) json[$last][$_set]("truncated", true);
      return json;
    }
    toString(opts) {
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[5] || CT.C5;
      if (minLevel == null) dart.nullFailed(I[1], 1653, 21, "minLevel");
      let result = super[$toString]();
      if (!(this.style != null)) dart.assertFailed(null, I[1], 1656, 12, "style != null");
      if (!(minLevel != null)) dart.assertFailed(null, I[1], 1657, 12, "minLevel != null");
      if (!dart.test(dart.fn(() => {
        if (dart.test(diagnostics$._isSingleLine(this.style))) {
          result = this.toStringDeep({parentConfiguration: parentConfiguration, minLevel: minLevel});
        } else {
          let description = dart.nullCheck(this.toDescription({parentConfiguration: parentConfiguration}));
          if (this.name == null || dart.nullCheck(this.name)[$isEmpty] || !dart.test(this.showName)) {
            result = description;
          } else {
            result = description[$contains]("\n") ? dart.str(this.name) + dart.str(this[_separator]) + "\n" + description : dart.str(this.name) + dart.str(this[_separator]) + " " + description;
          }
        }
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 1658, 12, "() {\r\n      if (_isSingleLine(style)) {\r\n        result = toStringDeep(\r\n            parentConfiguration: parentConfiguration, minLevel: minLevel);\r\n      } else {\r\n        final String description = toDescription(parentConfiguration: parentConfiguration)!;\r\n\r\n        if (name == null || name!.isEmpty || !showName) {\r\n          result = description;\r\n        } else {\r\n          result = description.contains('\\n') ? '$name$_separator\\n$description'\r\n              : '$name$_separator $description';\r\n        }\r\n      }\r\n      return true;\r\n    }()");
      return result;
    }
    get textTreeConfiguration() {
      if (!(this.style != null)) dart.assertFailed(null, I[1], 1681, 12, "style != null");
      switch (dart.nullCheck(this.style)) {
        case C[12] || CT.C12:
        {
          return null;
        }
        case C[15] || CT.C15:
        {
          return diagnostics$.denseTextConfiguration;
        }
        case C[13] || CT.C13:
        {
          return diagnostics$.sparseTextConfiguration;
        }
        case C[14] || CT.C14:
        {
          return diagnostics$.dashedTextConfiguration;
        }
        case C[18] || CT.C18:
        {
          return diagnostics$.whitespaceTextConfiguration;
        }
        case C[16] || CT.C16:
        {
          return diagnostics$.transitionTextConfiguration;
        }
        case C[20] || CT.C20:
        {
          return diagnostics$.singleLineTextConfiguration;
        }
        case C[21] || CT.C21:
        {
          return diagnostics$.errorPropertyTextConfiguration;
        }
        case C[22] || CT.C22:
        {
          return diagnostics$.shallowTextConfiguration;
        }
        case C[17] || CT.C17:
        {
          return diagnostics$.errorTextConfiguration;
        }
        case C[23] || CT.C23:
        {
          return diagnostics$.whitespaceTextConfiguration;
        }
        case C[19] || CT.C19:
        {
          return diagnostics$.flatTextConfiguration;
        }
        default:
        {
          dart.throw(new _internal.ReachabilityError.new("`null` encountered as case in a switch expression with a non-nullable enum type."));
        }
      }
    }
    toStringDeep(opts) {
      let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : "";
      if (prefixLineOne == null) dart.nullFailed(I[1], 1733, 12, "prefixLineOne");
      let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[4] || CT.C4;
      if (minLevel == null) dart.nullFailed(I[1], 1736, 21, "minLevel");
      let result = "";
      if (!dart.test(dart.fn(() => {
        result = new diagnostics$.TextTreeRenderer.new({minLevel: minLevel, wrapWidth: 65, wrapWidthProperties: 65}).render(this, {prefixLineOne: prefixLineOne, prefixOtherLines: prefixOtherLines, parentConfiguration: parentConfiguration});
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 1739, 12, "() {\r\n      result = TextTreeRenderer(\r\n        minLevel: minLevel,\r\n        wrapWidth: 65,\r\n        wrapWidthProperties: 65,\r\n      ).render(\r\n        this,\r\n        prefixLineOne: prefixLineOne,\r\n        prefixOtherLines: prefixOtherLines,\r\n        parentConfiguration: parentConfiguration,\r\n      );\r\n      return true;\r\n    }()");
      return result;
    }
  };
  (diagnostics$.DiagnosticsNode.new = function(opts) {
    let name = opts && 'name' in opts ? opts.name : null;
    let style = opts && 'style' in opts ? opts.style : null;
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 1426, 10, "showName");
    let showSeparator = opts && 'showSeparator' in opts ? opts.showSeparator : true;
    if (showSeparator == null) dart.nullFailed(I[1], 1427, 10, "showSeparator");
    let linePrefix = opts && 'linePrefix' in opts ? opts.linePrefix : null;
    this[name$] = name;
    this[style$] = style;
    this[showName$] = showName;
    this[showSeparator$] = showSeparator;
    this[linePrefix$] = linePrefix;
    if (!(showName != null)) dart.assertFailed(null, I[1], 1429, 15, "showName != null");
    if (!(showSeparator != null)) dart.assertFailed(null, I[1], 1430, 15, "showSeparator != null");
    if (!(name == null || !name[$endsWith](":"))) dart.assertFailed("Names of diagnostic nodes must not end with colons.\n" + "name:\n" + "  \"" + dart.str(name) + "\"", I[1], 1435, 10, "name == null || !name.endsWith(':')");
    ;
  }).prototype = diagnostics$.DiagnosticsNode.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticsNode);
  dart.addTypeCaches(diagnostics$.DiagnosticsNode);
  dart.setMethodSignature(diagnostics$.DiagnosticsNode, () => ({
    __proto__: dart.getMethods(diagnostics$.DiagnosticsNode.__proto__),
    isFiltered: dart.fnType(core.bool, [diagnostics$.DiagnosticLevel]),
    toJsonMap: dart.fnType(core.Map$(core.String, dart.nullable(core.Object)), [diagnostics$.DiagnosticsSerializationDelegate]),
    toString: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel, parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)}, {}),
    [$toString]: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel, parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)}, {}),
    toStringDeep: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel, parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration), prefixLineOne: core.String, prefixOtherLines: dart.nullable(core.String)}, {})
  }));
  dart.setGetterSignature(diagnostics$.DiagnosticsNode, () => ({
    __proto__: dart.getGetters(diagnostics$.DiagnosticsNode.__proto__),
    level: diagnostics$.DiagnosticLevel,
    emptyBodyDescription: dart.nullable(core.String),
    allowWrap: core.bool,
    allowNameWrap: core.bool,
    allowTruncate: core.bool,
    [_separator]: core.String,
    textTreeConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)
  }));
  dart.setLibraryUri(diagnostics$.DiagnosticsNode, I[2]);
  dart.setFieldSignature(diagnostics$.DiagnosticsNode, () => ({
    __proto__: dart.getFields(diagnostics$.DiagnosticsNode.__proto__),
    name: dart.finalFieldType(dart.nullable(core.String)),
    showSeparator: dart.finalFieldType(core.bool),
    showName: dart.finalFieldType(core.bool),
    linePrefix: dart.finalFieldType(dart.nullable(core.String)),
    style: dart.finalFieldType(dart.nullable(diagnostics$.DiagnosticsTreeStyle))
  }));
  dart.defineExtensionMethods(diagnostics$.DiagnosticsNode, ['toString']);
  var expandableValue$ = dart.privateName(diagnostics$, "DiagnosticsProperty.expandableValue");
  var allowWrap$ = dart.privateName(diagnostics$, "DiagnosticsProperty.allowWrap");
  var allowNameWrap$ = dart.privateName(diagnostics$, "DiagnosticsProperty.allowNameWrap");
  var ifNull$ = dart.privateName(diagnostics$, "DiagnosticsProperty.ifNull");
  var ifEmpty$ = dart.privateName(diagnostics$, "DiagnosticsProperty.ifEmpty");
  var tooltip$ = dart.privateName(diagnostics$, "DiagnosticsProperty.tooltip");
  var missingIfNull$ = dart.privateName(diagnostics$, "DiagnosticsProperty.missingIfNull");
  var defaultValue$ = dart.privateName(diagnostics$, "DiagnosticsProperty.defaultValue");
  var _exception = dart.privateName(diagnostics$, "_exception");
  var _description = dart.privateName(diagnostics$, "_description");
  var _valueComputed = dart.privateName(diagnostics$, "_valueComputed");
  var _value = dart.privateName(diagnostics$, "_value");
  var _computeValue = dart.privateName(diagnostics$, "_computeValue");
  var _defaultLevel = dart.privateName(diagnostics$, "_defaultLevel");
  var _addTooltip = dart.privateName(diagnostics$, "_addTooltip");
  var _maybeCacheValue = dart.privateName(diagnostics$, "_maybeCacheValue");
  const _is_DiagnosticsProperty_default = Symbol('_is_DiagnosticsProperty_default');
  diagnostics$.DiagnosticsProperty$ = dart.generic(T => {
    var TN = () => (TN = dart.constFn(dart.nullable(T)))();
    class DiagnosticsProperty extends diagnostics$.DiagnosticsNode {
      get expandableValue() {
        return this[expandableValue$];
      }
      set expandableValue(value) {
        super.expandableValue = value;
      }
      get allowWrap() {
        return this[allowWrap$];
      }
      set allowWrap(value) {
        super.allowWrap = value;
      }
      get allowNameWrap() {
        return this[allowNameWrap$];
      }
      set allowNameWrap(value) {
        super.allowNameWrap = value;
      }
      get ifNull() {
        return this[ifNull$];
      }
      set ifNull(value) {
        super.ifNull = value;
      }
      get ifEmpty() {
        return this[ifEmpty$];
      }
      set ifEmpty(value) {
        super.ifEmpty = value;
      }
      get tooltip() {
        return this[tooltip$];
      }
      set tooltip(value) {
        super.tooltip = value;
      }
      get missingIfNull() {
        return this[missingIfNull$];
      }
      set missingIfNull(value) {
        super.missingIfNull = value;
      }
      get defaultValue() {
        return this[defaultValue$];
      }
      set defaultValue(value) {
        super.defaultValue = value;
      }
      toJsonMap(delegate) {
        if (delegate == null) dart.nullFailed(I[1], 2682, 67, "delegate");
        let v = this.value;
        let properties = null;
        if (dart.test(delegate.expandPropertyValues) && dart.test(delegate.includeProperties) && diagnostics$.Diagnosticable.is(v) && dart.test(this.getProperties()[$isEmpty])) {
          delegate = delegate.copyWith({subtreeDepth: 0, includeProperties: false});
          properties = diagnostics$.DiagnosticsNode.toJsonList(delegate.filterProperties(v.toDiagnosticsNode().getProperties(), this), this, delegate);
        }
        let json = super.toJsonMap(delegate);
        if (properties != null) {
          json[$_set]("properties", properties);
        }
        if (!dart.equals(this.defaultValue, diagnostics$.kNoDefaultValue)) json[$_set]("defaultValue", dart.toString(this.defaultValue));
        if (this.ifEmpty != null) json[$_set]("ifEmpty", this.ifEmpty);
        if (this.ifNull != null) json[$_set]("ifNull", this.ifNull);
        if (this.tooltip != null) json[$_set]("tooltip", this.tooltip);
        json[$_set]("missingIfNull", this.missingIfNull);
        if (this.exception != null) json[$_set]("exception", dart.toString(this.exception));
        json[$_set]("propertyType", dart.toString(this.propertyType));
        json[$_set]("defaultLevel", diagnostics$.describeEnum(this[_defaultLevel]));
        if (diagnostics$.Diagnosticable.is(this.value) || diagnostics$.DiagnosticsNode.is(this.value)) json[$_set]("isDiagnosticableValue", true);
        if (typeof v == 'number') json[$_set]("value", v[$isFinite] ? v : dart.toString(v));
        if (typeof this.value == 'string' || typeof this.value == 'boolean' || this.value == null) json[$_set]("value", this.value);
        return json;
      }
      valueToString(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        let v = this.value;
        return diagnostics$.DiagnosticableTree.is(v) ? v.toStringShort() : dart.toString(v);
      }
      toDescription(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        if (this[_description] != null) return this[_addTooltip](dart.nullCheck(this[_description]));
        if (this.exception != null) return "EXCEPTION (" + dart.str(dart.runtimeType(this.exception)) + ")";
        if (this.ifNull != null && this.value == null) return this[_addTooltip](dart.nullCheck(this.ifNull));
        let result = this.valueToString({parentConfiguration: parentConfiguration});
        if (result[$isEmpty] && this.ifEmpty != null) result = dart.nullCheck(this.ifEmpty);
        return this[_addTooltip](result);
      }
      [_addTooltip](text) {
        if (text == null) dart.nullFailed(I[1], 2765, 29, "text");
        if (!(text != null)) dart.assertFailed(null, I[1], 2766, 12, "text != null");
        return this.tooltip == null ? text : dart.str(text) + " (" + dart.str(this.tooltip) + ")";
      }
      get propertyType() {
        return dart.wrapType(T);
      }
      get value() {
        this[_maybeCacheValue]();
        return this[_value];
      }
      get exception() {
        this[_maybeCacheValue]();
        return this[_exception];
      }
      [_maybeCacheValue]() {
        if (dart.test(this[_valueComputed])) return;
        this[_valueComputed] = true;
        if (!(this[_computeValue] != null)) dart.assertFailed(null, I[1], 2836, 12, "_computeValue != null");
        try {
          this[_value] = dart.nullCheck(this[_computeValue])();
        } catch (e) {
          let exception = dart.getThrown(e);
          if (core.Object.is(exception)) {
            this[_exception] = exception;
            this[_value] = null;
          } else
            throw e;
        }
      }
      get level() {
        if (this[_defaultLevel] == diagnostics$.DiagnosticLevel.hidden) return this[_defaultLevel];
        if (this.exception != null) return diagnostics$.DiagnosticLevel.error;
        if (this.value == null && dart.test(this.missingIfNull)) return diagnostics$.DiagnosticLevel.warning;
        if (!dart.equals(this.defaultValue, diagnostics$.kNoDefaultValue) && dart.equals(this.value, this.defaultValue)) return diagnostics$.DiagnosticLevel.fine;
        return this[_defaultLevel];
      }
      getProperties() {
        if (dart.test(this.expandableValue)) {
          let object = this.value;
          if (diagnostics$.DiagnosticsNode.is(object)) {
            return object.getProperties();
          }
          if (diagnostics$.Diagnosticable.is(object)) {
            return object.toDiagnosticsNode({style: this.style}).getProperties();
          }
        }
        return C[31] || CT.C31;
      }
      getChildren() {
        if (dart.test(this.expandableValue)) {
          let object = this.value;
          if (diagnostics$.DiagnosticsNode.is(object)) {
            return object.getChildren();
          }
          if (diagnostics$.Diagnosticable.is(object)) {
            return object.toDiagnosticsNode({style: this.style}).getChildren();
          }
        }
        return C[31] || CT.C31;
      }
    }
    (DiagnosticsProperty.new = function(name, value, opts) {
      let t7;
      let description = opts && 'description' in opts ? opts.description : null;
      let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
      let ifEmpty = opts && 'ifEmpty' in opts ? opts.ifEmpty : null;
      let showName = opts && 'showName' in opts ? opts.showName : true;
      if (showName == null) dart.nullFailed(I[1], 2593, 10, "showName");
      let showSeparator = opts && 'showSeparator' in opts ? opts.showSeparator : true;
      if (showSeparator == null) dart.nullFailed(I[1], 2594, 10, "showSeparator");
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
      let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
      let missingIfNull = opts && 'missingIfNull' in opts ? opts.missingIfNull : false;
      if (missingIfNull == null) dart.nullFailed(I[1], 2597, 10, "missingIfNull");
      let linePrefix = opts && 'linePrefix' in opts ? opts.linePrefix : null;
      let expandableValue = opts && 'expandableValue' in opts ? opts.expandableValue : false;
      if (expandableValue == null) dart.nullFailed(I[1], 2599, 10, "expandableValue");
      let allowWrap = opts && 'allowWrap' in opts ? opts.allowWrap : true;
      if (allowWrap == null) dart.nullFailed(I[1], 2600, 10, "allowWrap");
      let allowNameWrap = opts && 'allowNameWrap' in opts ? opts.allowNameWrap : true;
      if (allowNameWrap == null) dart.nullFailed(I[1], 2601, 10, "allowNameWrap");
      let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
      if (style == null) dart.nullFailed(I[1], 2602, 26, "style");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2603, 21, "level");
      this[_exception] = null;
      this[ifEmpty$] = ifEmpty;
      this[defaultValue$] = defaultValue;
      this[tooltip$] = tooltip;
      this[missingIfNull$] = missingIfNull;
      this[expandableValue$] = expandableValue;
      this[allowWrap$] = allowWrap;
      this[allowNameWrap$] = allowNameWrap;
      if (!(showName != null)) dart.assertFailed(null, I[1], 2604, 15, "showName != null");
      if (!(showSeparator != null)) dart.assertFailed(null, I[1], 2605, 15, "showSeparator != null");
      if (!(style != null)) dart.assertFailed(null, I[1], 2606, 15, "style != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 2607, 15, "level != null");
      this[_description] = description;
      this[_valueComputed] = true;
      this[_value] = value;
      this[_computeValue] = null;
      this[ifNull$] = (t7 = ifNull, t7 == null ? dart.test(missingIfNull) ? "MISSING" : null : t7);
      this[_defaultLevel] = level;
      DiagnosticsProperty.__proto__.new.call(this, {name: name, showName: showName, showSeparator: showSeparator, style: style, linePrefix: linePrefix});
      ;
    }).prototype = DiagnosticsProperty.prototype;
    (DiagnosticsProperty.lazy = function(name, computeValue, opts) {
      let t7;
      if (computeValue == null) dart.nullFailed(I[1], 2636, 37, "computeValue");
      let description = opts && 'description' in opts ? opts.description : null;
      let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
      let ifEmpty = opts && 'ifEmpty' in opts ? opts.ifEmpty : null;
      let showName = opts && 'showName' in opts ? opts.showName : true;
      if (showName == null) dart.nullFailed(I[1], 2640, 10, "showName");
      let showSeparator = opts && 'showSeparator' in opts ? opts.showSeparator : true;
      if (showSeparator == null) dart.nullFailed(I[1], 2641, 10, "showSeparator");
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
      let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
      let missingIfNull = opts && 'missingIfNull' in opts ? opts.missingIfNull : false;
      if (missingIfNull == null) dart.nullFailed(I[1], 2644, 10, "missingIfNull");
      let expandableValue = opts && 'expandableValue' in opts ? opts.expandableValue : false;
      if (expandableValue == null) dart.nullFailed(I[1], 2645, 10, "expandableValue");
      let allowWrap = opts && 'allowWrap' in opts ? opts.allowWrap : true;
      if (allowWrap == null) dart.nullFailed(I[1], 2646, 10, "allowWrap");
      let allowNameWrap = opts && 'allowNameWrap' in opts ? opts.allowNameWrap : true;
      if (allowNameWrap == null) dart.nullFailed(I[1], 2647, 10, "allowNameWrap");
      let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
      if (style == null) dart.nullFailed(I[1], 2648, 26, "style");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2649, 21, "level");
      this[_exception] = null;
      this[ifEmpty$] = ifEmpty;
      this[defaultValue$] = defaultValue;
      this[tooltip$] = tooltip;
      this[missingIfNull$] = missingIfNull;
      this[expandableValue$] = expandableValue;
      this[allowWrap$] = allowWrap;
      this[allowNameWrap$] = allowNameWrap;
      if (!(showName != null)) dart.assertFailed(null, I[1], 2650, 15, "showName != null");
      if (!(showSeparator != null)) dart.assertFailed(null, I[1], 2651, 15, "showSeparator != null");
      if (!(dart.equals(defaultValue, diagnostics$.kNoDefaultValue) || TN().is(defaultValue))) dart.assertFailed(null, I[1], 2652, 15, "defaultValue == kNoDefaultValue || defaultValue is T?");
      if (!(missingIfNull != null)) dart.assertFailed(null, I[1], 2653, 15, "missingIfNull != null");
      if (!(style != null)) dart.assertFailed(null, I[1], 2654, 15, "style != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 2655, 15, "level != null");
      this[_description] = description;
      this[_valueComputed] = false;
      this[_value] = null;
      this[_computeValue] = computeValue;
      this[_defaultLevel] = level;
      this[ifNull$] = (t7 = ifNull, t7 == null ? dart.test(missingIfNull) ? "MISSING" : null : t7);
      DiagnosticsProperty.__proto__.new.call(this, {name: name, showName: showName, showSeparator: showSeparator, style: style});
      ;
    }).prototype = DiagnosticsProperty.prototype;
    dart.addTypeTests(DiagnosticsProperty);
    DiagnosticsProperty.prototype[_is_DiagnosticsProperty_default] = true;
    dart.addTypeCaches(DiagnosticsProperty);
    dart.setMethodSignature(DiagnosticsProperty, () => ({
      __proto__: dart.getMethods(DiagnosticsProperty.__proto__),
      valueToString: dart.fnType(core.String, [], {parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)}, {}),
      toDescription: dart.fnType(core.String, [], {parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)}, {}),
      [_addTooltip]: dart.fnType(core.String, [core.String]),
      [_maybeCacheValue]: dart.fnType(dart.void, []),
      getProperties: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), []),
      getChildren: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), [])
    }));
    dart.setGetterSignature(DiagnosticsProperty, () => ({
      __proto__: dart.getGetters(DiagnosticsProperty.__proto__),
      propertyType: core.Type,
      value: dart.nullable(T),
      exception: dart.nullable(core.Object)
    }));
    dart.setLibraryUri(DiagnosticsProperty, I[2]);
    dart.setFieldSignature(DiagnosticsProperty, () => ({
      __proto__: dart.getFields(DiagnosticsProperty.__proto__),
      [_description]: dart.finalFieldType(dart.nullable(core.String)),
      expandableValue: dart.finalFieldType(core.bool),
      allowWrap: dart.finalFieldType(core.bool),
      allowNameWrap: dart.finalFieldType(core.bool),
      ifNull: dart.finalFieldType(dart.nullable(core.String)),
      ifEmpty: dart.finalFieldType(dart.nullable(core.String)),
      tooltip: dart.finalFieldType(dart.nullable(core.String)),
      missingIfNull: dart.finalFieldType(core.bool),
      [_value]: dart.fieldType(dart.nullable(T)),
      [_valueComputed]: dart.fieldType(core.bool),
      [_exception]: dart.fieldType(dart.nullable(core.Object)),
      defaultValue: dart.finalFieldType(dart.nullable(core.Object)),
      [_defaultLevel]: dart.finalFieldType(diagnostics$.DiagnosticLevel),
      [_computeValue]: dart.finalFieldType(dart.nullable(dart.fnType(dart.nullable(T), [])))
    }));
    return DiagnosticsProperty;
  });
  diagnostics$.DiagnosticsProperty = diagnostics$.DiagnosticsProperty$();
  dart.addTypeTests(diagnostics$.DiagnosticsProperty, _is_DiagnosticsProperty_default);
  diagnostics$.MessageProperty = class MessageProperty extends diagnostics$.DiagnosticsProperty$(dart.void) {};
  (diagnostics$.MessageProperty.new = function(name, message, opts) {
    if (name == null) dart.nullFailed(I[1], 1793, 12, "name");
    if (message == null) dart.nullFailed(I[1], 1794, 12, "message");
    let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
    if (style == null) dart.nullFailed(I[1], 1795, 26, "style");
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 1796, 21, "level");
    if (!(name != null)) dart.assertFailed(null, I[1], 1797, 15, "name != null");
    if (!(message != null)) dart.assertFailed(null, I[1], 1798, 15, "message != null");
    if (!(style != null)) dart.assertFailed(null, I[1], 1799, 15, "style != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 1800, 15, "level != null");
    diagnostics$.MessageProperty.__proto__.new.call(this, name, null, {description: message, style: style, level: level});
    ;
  }).prototype = diagnostics$.MessageProperty.prototype;
  dart.addTypeTests(diagnostics$.MessageProperty);
  dart.addTypeCaches(diagnostics$.MessageProperty);
  dart.setLibraryUri(diagnostics$.MessageProperty, I[2]);
  var quoted$ = dart.privateName(diagnostics$, "StringProperty.quoted");
  diagnostics$.StringProperty = class StringProperty extends diagnostics$.DiagnosticsProperty$(core.String) {
    get quoted() {
      return this[quoted$];
    }
    set quoted(value) {
      super.quoted = value;
    }
    toJsonMap(delegate) {
      if (delegate == null) dart.nullFailed(I[1], 1845, 67, "delegate");
      let json = super.toJsonMap(delegate);
      json[$_set]("quoted", this.quoted);
      return json;
    }
    valueToString(opts) {
      let t8;
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      let text = (t8 = this[_description], t8 == null ? this.value : t8);
      if (parentConfiguration != null && !dart.test(parentConfiguration.lineBreakProperties) && text != null) {
        text = text[$replaceAll]("\n", "\\n");
      }
      if (dart.test(this.quoted) && text != null) {
        if (this.ifEmpty != null && text[$isEmpty]) return dart.nullCheck(this.ifEmpty);
        return "\"" + dart.str(text) + "\"";
      }
      return dart.toString(text);
    }
  };
  (diagnostics$.StringProperty.new = function(name, value, opts) {
    if (name == null) dart.nullFailed(I[1], 1815, 12, "name");
    let description = opts && 'description' in opts ? opts.description : null;
    let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 1819, 10, "showName");
    let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
    let quoted = opts && 'quoted' in opts ? opts.quoted : true;
    if (quoted == null) dart.nullFailed(I[1], 1821, 10, "quoted");
    let ifEmpty = opts && 'ifEmpty' in opts ? opts.ifEmpty : null;
    let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
    if (style == null) dart.nullFailed(I[1], 1823, 26, "style");
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 1824, 21, "level");
    this[quoted$] = quoted;
    if (!(showName != null)) dart.assertFailed(null, I[1], 1825, 15, "showName != null");
    if (!(quoted != null)) dart.assertFailed(null, I[1], 1826, 15, "quoted != null");
    if (!(style != null)) dart.assertFailed(null, I[1], 1827, 15, "style != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 1828, 15, "level != null");
    diagnostics$.StringProperty.__proto__.new.call(this, name, value, {description: description, defaultValue: defaultValue, tooltip: tooltip, showName: showName, ifEmpty: ifEmpty, style: style, level: level});
    ;
  }).prototype = diagnostics$.StringProperty.prototype;
  dart.addTypeTests(diagnostics$.StringProperty);
  dart.addTypeCaches(diagnostics$.StringProperty);
  dart.setLibraryUri(diagnostics$.StringProperty, I[2]);
  dart.setFieldSignature(diagnostics$.StringProperty, () => ({
    __proto__: dart.getFields(diagnostics$.StringProperty.__proto__),
    quoted: dart.finalFieldType(core.bool)
  }));
  var unit$ = dart.privateName(diagnostics$, "_NumProperty.unit");
  const _is__NumProperty_default = Symbol('_is__NumProperty_default');
  diagnostics$._NumProperty$ = dart.generic(T => {
    class _NumProperty extends diagnostics$.DiagnosticsProperty$(T) {
      get unit() {
        return this[unit$];
      }
      set unit(value) {
        super.unit = value;
      }
      toJsonMap(delegate) {
        if (delegate == null) dart.nullFailed(I[1], 1918, 67, "delegate");
        let json = super.toJsonMap(delegate);
        if (this.unit != null) json[$_set]("unit", this.unit);
        json[$_set]("numberToString", this.numberToString());
        return json;
      }
      valueToString(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        if (this.value == null) return dart.toString(this.value);
        return this.unit != null ? dart.str(this.numberToString()) + dart.str(this.unit) : this.numberToString();
      }
    }
    (_NumProperty.new = function(name, value, opts) {
      if (name == null) dart.nullFailed(I[1], 1876, 12, "name");
      let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
      let unit = opts && 'unit' in opts ? opts.unit : null;
      let showName = opts && 'showName' in opts ? opts.showName : true;
      if (showName == null) dart.nullFailed(I[1], 1880, 10, "showName");
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
      let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
      let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
      if (style == null) dart.nullFailed(I[1], 1883, 26, "style");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 1884, 21, "level");
      this[unit$] = unit;
      _NumProperty.__proto__.new.call(this, name, value, {ifNull: ifNull, showName: showName, defaultValue: defaultValue, tooltip: tooltip, level: level, style: style});
      ;
    }).prototype = _NumProperty.prototype;
    (_NumProperty.lazy = function(name, computeValue, opts) {
      if (name == null) dart.nullFailed(I[1], 1897, 12, "name");
      if (computeValue == null) dart.nullFailed(I[1], 1898, 38, "computeValue");
      let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
      let unit = opts && 'unit' in opts ? opts.unit : null;
      let showName = opts && 'showName' in opts ? opts.showName : true;
      if (showName == null) dart.nullFailed(I[1], 1901, 10, "showName");
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
      let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
      let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
      if (style == null) dart.nullFailed(I[1], 1904, 26, "style");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 1905, 21, "level");
      this[unit$] = unit;
      _NumProperty.__proto__.lazy.call(this, name, computeValue, {ifNull: ifNull, showName: showName, defaultValue: defaultValue, tooltip: tooltip, style: style, level: level});
      ;
    }).prototype = _NumProperty.prototype;
    dart.addTypeTests(_NumProperty);
    _NumProperty.prototype[_is__NumProperty_default] = true;
    dart.addTypeCaches(_NumProperty);
    dart.setLibraryUri(_NumProperty, I[2]);
    dart.setFieldSignature(_NumProperty, () => ({
      __proto__: dart.getFields(_NumProperty.__proto__),
      unit: dart.finalFieldType(dart.nullable(core.String))
    }));
    return _NumProperty;
  });
  diagnostics$._NumProperty = diagnostics$._NumProperty$();
  dart.addTypeTests(diagnostics$._NumProperty, _is__NumProperty_default);
  diagnostics$.DoubleProperty = class DoubleProperty extends diagnostics$._NumProperty$(core.double) {
    numberToString() {
      return debug.debugFormatDouble(this.value);
    }
  };
  (diagnostics$.DoubleProperty.new = function(name, value, opts) {
    if (name == null) dart.nullFailed(I[1], 1953, 12, "name");
    let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
    let unit = opts && 'unit' in opts ? opts.unit : null;
    let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
    let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 1959, 10, "showName");
    let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
    if (style == null) dart.nullFailed(I[1], 1960, 26, "style");
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 1961, 21, "level");
    if (!(showName != null)) dart.assertFailed(null, I[1], 1962, 15, "showName != null");
    if (!(style != null)) dart.assertFailed(null, I[1], 1963, 15, "style != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 1964, 15, "level != null");
    diagnostics$.DoubleProperty.__proto__.new.call(this, name, value, {ifNull: ifNull, unit: unit, tooltip: tooltip, defaultValue: defaultValue, showName: showName, style: style, level: level});
    ;
  }).prototype = diagnostics$.DoubleProperty.prototype;
  (diagnostics$.DoubleProperty.lazy = function(name, computeValue, opts) {
    if (name == null) dart.nullFailed(I[1], 1984, 12, "name");
    if (computeValue == null) dart.nullFailed(I[1], 1985, 43, "computeValue");
    let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 1987, 10, "showName");
    let unit = opts && 'unit' in opts ? opts.unit : null;
    let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
    let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 1991, 21, "level");
    if (!(showName != null)) dart.assertFailed(null, I[1], 1992, 15, "showName != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 1993, 15, "level != null");
    diagnostics$.DoubleProperty.__proto__.lazy.call(this, name, computeValue, {showName: showName, ifNull: ifNull, unit: unit, tooltip: tooltip, defaultValue: defaultValue, level: level});
    ;
  }).prototype = diagnostics$.DoubleProperty.prototype;
  dart.addTypeTests(diagnostics$.DoubleProperty);
  dart.addTypeCaches(diagnostics$.DoubleProperty);
  dart.setMethodSignature(diagnostics$.DoubleProperty, () => ({
    __proto__: dart.getMethods(diagnostics$.DoubleProperty.__proto__),
    numberToString: dart.fnType(core.String, [])
  }));
  dart.setLibraryUri(diagnostics$.DoubleProperty, I[2]);
  diagnostics$.IntProperty = class IntProperty extends diagnostics$._NumProperty$(core.int) {
    numberToString() {
      return dart.toString(this.value);
    }
  };
  (diagnostics$.IntProperty.new = function(name, value, opts) {
    if (name == null) dart.nullFailed(I[1], 2017, 12, "name");
    let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 2020, 10, "showName");
    let unit = opts && 'unit' in opts ? opts.unit : null;
    let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
    let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
    if (style == null) dart.nullFailed(I[1], 2023, 26, "style");
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 2024, 21, "level");
    if (!(showName != null)) dart.assertFailed(null, I[1], 2025, 15, "showName != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 2026, 15, "level != null");
    if (!(style != null)) dart.assertFailed(null, I[1], 2027, 15, "style != null");
    diagnostics$.IntProperty.__proto__.new.call(this, name, value, {ifNull: ifNull, showName: showName, unit: unit, defaultValue: defaultValue, level: level});
    ;
  }).prototype = diagnostics$.IntProperty.prototype;
  dart.addTypeTests(diagnostics$.IntProperty);
  dart.addTypeCaches(diagnostics$.IntProperty);
  dart.setMethodSignature(diagnostics$.IntProperty, () => ({
    __proto__: dart.getMethods(diagnostics$.IntProperty.__proto__),
    numberToString: dart.fnType(core.String, [])
  }));
  dart.setLibraryUri(diagnostics$.IntProperty, I[2]);
  diagnostics$.PercentProperty = class PercentProperty extends diagnostics$.DoubleProperty {
    valueToString(opts) {
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      if (this.value == null) return dart.toString(this.value);
      return this.unit != null ? dart.str(this.numberToString()) + " " + dart.str(this.unit) : this.numberToString();
    }
    numberToString() {
      let v = this.value;
      if (v == null) return dart.toString(this.value);
      return (v[$clamp](0.0, 1.0) * 100.0)[$toStringAsFixed](1) + "%";
    }
  };
  (diagnostics$.PercentProperty.new = function(name, fraction, opts) {
    if (name == null) dart.nullFailed(I[1], 2054, 12, "name");
    let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 2057, 10, "showName");
    let tooltip = opts && 'tooltip' in opts ? opts.tooltip : null;
    let unit = opts && 'unit' in opts ? opts.unit : null;
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 2060, 21, "level");
    if (!(showName != null)) dart.assertFailed(null, I[1], 2061, 15, "showName != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 2062, 15, "level != null");
    diagnostics$.PercentProperty.__proto__.new.call(this, name, fraction, {ifNull: ifNull, showName: showName, tooltip: tooltip, unit: unit, level: level});
    ;
  }).prototype = diagnostics$.PercentProperty.prototype;
  dart.addTypeTests(diagnostics$.PercentProperty);
  dart.addTypeCaches(diagnostics$.PercentProperty);
  dart.setLibraryUri(diagnostics$.PercentProperty, I[2]);
  var ifTrue$ = dart.privateName(diagnostics$, "FlagProperty.ifTrue");
  var ifFalse$ = dart.privateName(diagnostics$, "FlagProperty.ifFalse");
  diagnostics$.FlagProperty = class FlagProperty extends diagnostics$.DiagnosticsProperty$(core.bool) {
    get ifTrue() {
      return this[ifTrue$];
    }
    set ifTrue(value) {
      super.ifTrue = value;
    }
    get ifFalse() {
      return this[ifFalse$];
    }
    set ifFalse(value) {
      super.ifFalse = value;
    }
    toJsonMap(delegate) {
      if (delegate == null) dart.nullFailed(I[1], 2155, 67, "delegate");
      let json = super.toJsonMap(delegate);
      if (this.ifTrue != null) json[$_set]("ifTrue", this.ifTrue);
      if (this.ifFalse != null) json[$_set]("ifFalse", this.ifFalse);
      return json;
    }
    valueToString(opts) {
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      if (this.value === true) {
        if (this.ifTrue != null) return dart.nullCheck(this.ifTrue);
      } else if (this.value === false) {
        if (this.ifFalse != null) return dart.nullCheck(this.ifFalse);
      }
      return super.valueToString({parentConfiguration: parentConfiguration});
    }
    get showName() {
      if (this.value == null || this.value === true && this.ifTrue == null || this.value === false && this.ifFalse == null) {
        return true;
      }
      return super.showName;
    }
    get level() {
      if (this.value === true) {
        if (this.ifTrue == null) return diagnostics$.DiagnosticLevel.hidden;
      }
      if (this.value === false) {
        if (this.ifFalse == null) return diagnostics$.DiagnosticLevel.hidden;
      }
      return super.level;
    }
  };
  (diagnostics$.FlagProperty.new = function(name, opts) {
    if (name == null) dart.nullFailed(I[1], 2136, 12, "name");
    let value = opts && 'value' in opts ? opts.value : null;
    let ifTrue = opts && 'ifTrue' in opts ? opts.ifTrue : null;
    let ifFalse = opts && 'ifFalse' in opts ? opts.ifFalse : null;
    let showName = opts && 'showName' in opts ? opts.showName : false;
    if (showName == null) dart.nullFailed(I[1], 2140, 10, "showName");
    let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : null;
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 2142, 21, "level");
    this[ifTrue$] = ifTrue;
    this[ifFalse$] = ifFalse;
    if (!(showName != null)) dart.assertFailed(null, I[1], 2143, 15, "showName != null");
    if (!(level != null)) dart.assertFailed(null, I[1], 2144, 15, "level != null");
    if (!(ifTrue != null || ifFalse != null)) dart.assertFailed(null, I[1], 2145, 15, "ifTrue != null || ifFalse != null");
    diagnostics$.FlagProperty.__proto__.new.call(this, name, value, {showName: showName, defaultValue: defaultValue, level: level});
    ;
  }).prototype = diagnostics$.FlagProperty.prototype;
  dart.addTypeTests(diagnostics$.FlagProperty);
  dart.addTypeCaches(diagnostics$.FlagProperty);
  dart.setGetterSignature(diagnostics$.FlagProperty, () => ({
    __proto__: dart.getGetters(diagnostics$.FlagProperty.__proto__),
    showName: core.bool
  }));
  dart.setLibraryUri(diagnostics$.FlagProperty, I[2]);
  dart.setFieldSignature(diagnostics$.FlagProperty, () => ({
    __proto__: dart.getFields(diagnostics$.FlagProperty.__proto__),
    ifTrue: dart.finalFieldType(dart.nullable(core.String)),
    ifFalse: dart.finalFieldType(dart.nullable(core.String))
  }));
  const _is_IterableProperty_default = Symbol('_is_IterableProperty_default');
  diagnostics$.IterableProperty$ = dart.generic(T => {
    var TToString = () => (TToString = dart.constFn(dart.fnType(core.String, [T])))();
    class IterableProperty extends diagnostics$.DiagnosticsProperty$(core.Iterable$(T)) {
      valueToString(opts) {
        let t8;
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        if (this.value == null) return dart.toString(this.value);
        if (dart.test(dart.nullCheck(this.value)[$isEmpty])) {
          t8 = this.ifEmpty;
          return t8 == null ? "[]" : t8;
        }
        let formattedValues = dart.nullCheck(this.value)[$map](core.String, dart.fn(v => {
          if (dart.wrapType(T)._equals(dart.wrapType(core.double)) && typeof v == 'number') {
            return debug.debugFormatDouble(v);
          } else {
            return dart.toString(v);
          }
        }, TToString()));
        if (parentConfiguration != null && !dart.test(parentConfiguration.lineBreakProperties)) {
          return "[" + dart.str(formattedValues[$join](", ")) + "]";
        }
        return formattedValues[$join](dart.test(diagnostics$._isSingleLine(this.style)) ? ", " : "\n");
      }
      get level() {
        if (this.ifEmpty == null && this.value != null && dart.test(dart.nullCheck(this.value)[$isEmpty]) && super.level != diagnostics$.DiagnosticLevel.hidden) return diagnostics$.DiagnosticLevel.fine;
        return super.level;
      }
      toJsonMap(delegate) {
        if (delegate == null) dart.nullFailed(I[1], 2297, 67, "delegate");
        let json = super.toJsonMap(delegate);
        if (this.value != null) {
          json[$_set]("values", dart.nullCheck(this.value)[$map](core.String, dart.fn(value => dart.toString(value), TToString()))[$toList]());
        }
        return json;
      }
    }
    (IterableProperty.new = function(name, value, opts) {
      if (name == null) dart.nullFailed(I[1], 2232, 12, "name");
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
      let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
      let ifEmpty = opts && 'ifEmpty' in opts ? opts.ifEmpty : "[]";
      let style = opts && 'style' in opts ? opts.style : C[20] || CT.C20;
      if (style == null) dart.nullFailed(I[1], 2237, 26, "style");
      let showName = opts && 'showName' in opts ? opts.showName : true;
      if (showName == null) dart.nullFailed(I[1], 2238, 10, "showName");
      let showSeparator = opts && 'showSeparator' in opts ? opts.showSeparator : true;
      if (showSeparator == null) dart.nullFailed(I[1], 2239, 10, "showSeparator");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2240, 21, "level");
      if (!(style != null)) dart.assertFailed(null, I[1], 2241, 15, "style != null");
      if (!(showName != null)) dart.assertFailed(null, I[1], 2242, 15, "showName != null");
      if (!(showSeparator != null)) dart.assertFailed(null, I[1], 2243, 15, "showSeparator != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 2244, 15, "level != null");
      IterableProperty.__proto__.new.call(this, name, value, {defaultValue: defaultValue, ifNull: ifNull, ifEmpty: ifEmpty, style: style, showName: showName, showSeparator: showSeparator, level: level});
      ;
    }).prototype = IterableProperty.prototype;
    dart.addTypeTests(IterableProperty);
    IterableProperty.prototype[_is_IterableProperty_default] = true;
    dart.addTypeCaches(IterableProperty);
    dart.setLibraryUri(IterableProperty, I[2]);
    return IterableProperty;
  });
  diagnostics$.IterableProperty = diagnostics$.IterableProperty$();
  dart.addTypeTests(diagnostics$.IterableProperty, _is_IterableProperty_default);
  const _is_EnumProperty_default = Symbol('_is_EnumProperty_default');
  diagnostics$.EnumProperty$ = dart.generic(T => {
    class EnumProperty extends diagnostics$.DiagnosticsProperty$(T) {
      valueToString(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        if (this.value == null) return dart.toString(this.value);
        return diagnostics$.describeEnum(dart.nullCheck(this.value));
      }
    }
    (EnumProperty.new = function(name, value, opts) {
      if (name == null) dart.nullFailed(I[1], 2320, 12, "name");
      let defaultValue = opts && 'defaultValue' in opts ? opts.defaultValue : C[30] || CT.C30;
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2323, 21, "level");
      if (!(level != null)) dart.assertFailed(null, I[1], 2324, 15, "level != null");
      EnumProperty.__proto__.new.call(this, name, value, {defaultValue: defaultValue, level: level});
      ;
    }).prototype = EnumProperty.prototype;
    dart.addTypeTests(EnumProperty);
    EnumProperty.prototype[_is_EnumProperty_default] = true;
    dart.addTypeCaches(EnumProperty);
    dart.setLibraryUri(EnumProperty, I[2]);
    return EnumProperty;
  });
  diagnostics$.EnumProperty = diagnostics$.EnumProperty$();
  dart.addTypeTests(diagnostics$.EnumProperty, _is_EnumProperty_default);
  var ifPresent$ = dart.privateName(diagnostics$, "ObjectFlagProperty.ifPresent");
  const _is_ObjectFlagProperty_default = Symbol('_is_ObjectFlagProperty_default');
  diagnostics$.ObjectFlagProperty$ = dart.generic(T => {
    class ObjectFlagProperty extends diagnostics$.DiagnosticsProperty$(T) {
      get ifPresent() {
        return this[ifPresent$];
      }
      set ifPresent(value) {
        super.ifPresent = value;
      }
      valueToString(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        if (this.value != null) {
          if (this.ifPresent != null) return dart.nullCheck(this.ifPresent);
        } else {
          if (this.ifNull != null) return dart.nullCheck(this.ifNull);
        }
        return super.valueToString({parentConfiguration: parentConfiguration});
      }
      get showName() {
        if (this.value != null && this.ifPresent == null || this.value == null && this.ifNull == null) {
          return true;
        }
        return super.showName;
      }
      get level() {
        if (this.value != null) {
          if (this.ifPresent == null) return diagnostics$.DiagnosticLevel.hidden;
        } else {
          if (this.ifNull == null) return diagnostics$.DiagnosticLevel.hidden;
        }
        return super.level;
      }
      toJsonMap(delegate) {
        if (delegate == null) dart.nullFailed(I[1], 2452, 67, "delegate");
        let json = super.toJsonMap(delegate);
        if (this.ifPresent != null) json[$_set]("ifPresent", this.ifPresent);
        return json;
      }
    }
    (ObjectFlagProperty.new = function(name, value, opts) {
      if (name == null) dart.nullFailed(I[1], 2370, 12, "name");
      let ifPresent = opts && 'ifPresent' in opts ? opts.ifPresent : null;
      let ifNull = opts && 'ifNull' in opts ? opts.ifNull : null;
      let showName = opts && 'showName' in opts ? opts.showName : false;
      if (showName == null) dart.nullFailed(I[1], 2374, 10, "showName");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2375, 21, "level");
      this[ifPresent$] = ifPresent;
      if (!(ifPresent != null || ifNull != null)) dart.assertFailed(null, I[1], 2376, 15, "ifPresent != null || ifNull != null");
      if (!(showName != null)) dart.assertFailed(null, I[1], 2377, 15, "showName != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 2378, 15, "level != null");
      ObjectFlagProperty.__proto__.new.call(this, name, value, {showName: showName, ifNull: ifNull, level: level});
      ;
    }).prototype = ObjectFlagProperty.prototype;
    (ObjectFlagProperty.has = function(name, value, opts) {
      if (name == null) dart.nullFailed(I[1], 2394, 12, "name");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2396, 21, "level");
      if (!(name != null)) dart.assertFailed(null, I[1], 2397, 15, "name != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 2398, 15, "level != null");
      this[ifPresent$] = "has " + dart.str(name);
      ObjectFlagProperty.__proto__.new.call(this, name, value, {showName: false, level: level});
      ;
    }).prototype = ObjectFlagProperty.prototype;
    dart.addTypeTests(ObjectFlagProperty);
    ObjectFlagProperty.prototype[_is_ObjectFlagProperty_default] = true;
    dart.addTypeCaches(ObjectFlagProperty);
    dart.setGetterSignature(ObjectFlagProperty, () => ({
      __proto__: dart.getGetters(ObjectFlagProperty.__proto__),
      showName: core.bool
    }));
    dart.setLibraryUri(ObjectFlagProperty, I[2]);
    dart.setFieldSignature(ObjectFlagProperty, () => ({
      __proto__: dart.getFields(ObjectFlagProperty.__proto__),
      ifPresent: dart.finalFieldType(dart.nullable(core.String))
    }));
    return ObjectFlagProperty;
  });
  diagnostics$.ObjectFlagProperty = diagnostics$.ObjectFlagProperty$();
  dart.addTypeTests(diagnostics$.ObjectFlagProperty, _is_ObjectFlagProperty_default);
  var _hasNonNullEntry = dart.privateName(diagnostics$, "_hasNonNullEntry");
  var _formattedValues = dart.privateName(diagnostics$, "_formattedValues");
  const _is_FlagsSummary_default = Symbol('_is_FlagsSummary_default');
  diagnostics$.FlagsSummary$ = dart.generic(T => {
    var TN = () => (TN = dart.constFn(dart.nullable(T)))();
    var TNTobool = () => (TNTobool = dart.constFn(dart.fnType(core.bool, [TN()])))();
    class FlagsSummary extends diagnostics$.DiagnosticsProperty$(core.Map$(core.String, dart.nullable(T))) {
      get value() {
        return dart.nullCheck(super.value);
      }
      valueToString(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        if (!(this.value != null)) dart.assertFailed(null, I[1], 2512, 12, "value != null");
        if (!dart.test(this[_hasNonNullEntry]()) && this.ifEmpty != null) return dart.nullCheck(this.ifEmpty);
        let formattedValues = this[_formattedValues]();
        if (parentConfiguration != null && !dart.test(parentConfiguration.lineBreakProperties)) {
          return "[" + dart.str(formattedValues[$join](", ")) + "]";
        }
        return formattedValues[$join](dart.test(diagnostics$._isSingleLine(this.style)) ? ", " : "\n");
      }
      get level() {
        if (!dart.test(this[_hasNonNullEntry]()) && this.ifEmpty == null) return diagnostics$.DiagnosticLevel.hidden;
        return super.level;
      }
      toJsonMap(delegate) {
        if (delegate == null) dart.nullFailed(I[1], 2539, 67, "delegate");
        let json = super.toJsonMap(delegate);
        if (dart.test(this.value[$isNotEmpty])) json[$_set]("values", this[_formattedValues]()[$toList]());
        return json;
      }
      [_hasNonNullEntry]() {
        return this.value[$values][$any](dart.fn(o => o != null, TNTobool()));
      }
      [_formattedValues]() {
        return new (T$.SyncIterableOfString()).new((function* _formattedValues() {
          for (let entry of this.value[$entries]) {
            if (entry.value != null) {
              yield entry.key;
            }
          }
        }).bind(this));
      }
    }
    (FlagsSummary.new = function(name, value, opts) {
      if (name == null) dart.nullFailed(I[1], 2488, 12, "name");
      if (value == null) dart.nullFailed(I[1], 2489, 21, "value");
      let ifEmpty = opts && 'ifEmpty' in opts ? opts.ifEmpty : null;
      let showName = opts && 'showName' in opts ? opts.showName : true;
      if (showName == null) dart.nullFailed(I[1], 2491, 10, "showName");
      let showSeparator = opts && 'showSeparator' in opts ? opts.showSeparator : true;
      if (showSeparator == null) dart.nullFailed(I[1], 2492, 10, "showSeparator");
      let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
      if (level == null) dart.nullFailed(I[1], 2493, 21, "level");
      if (!(value != null)) dart.assertFailed(null, I[1], 2494, 15, "value != null");
      if (!(showName != null)) dart.assertFailed(null, I[1], 2495, 15, "showName != null");
      if (!(showSeparator != null)) dart.assertFailed(null, I[1], 2496, 15, "showSeparator != null");
      if (!(level != null)) dart.assertFailed(null, I[1], 2497, 15, "level != null");
      FlagsSummary.__proto__.new.call(this, name, value, {ifEmpty: ifEmpty, showName: showName, showSeparator: showSeparator, level: level});
      ;
    }).prototype = FlagsSummary.prototype;
    dart.addTypeTests(FlagsSummary);
    FlagsSummary.prototype[_is_FlagsSummary_default] = true;
    dart.addTypeCaches(FlagsSummary);
    dart.setMethodSignature(FlagsSummary, () => ({
      __proto__: dart.getMethods(FlagsSummary.__proto__),
      [_hasNonNullEntry]: dart.fnType(core.bool, []),
      [_formattedValues]: dart.fnType(core.Iterable$(core.String), [])
    }));
    dart.setGetterSignature(FlagsSummary, () => ({
      __proto__: dart.getGetters(FlagsSummary.__proto__),
      value: core.Map$(core.String, dart.nullable(T))
    }));
    dart.setLibraryUri(FlagsSummary, I[2]);
    return FlagsSummary;
  });
  diagnostics$.FlagsSummary = diagnostics$.FlagsSummary$();
  dart.addTypeTests(diagnostics$.FlagsSummary, _is_FlagsSummary_default);
  var value$ = dart.privateName(diagnostics$, "DiagnosticableNode.value");
  var _cachedBuilder = dart.privateName(diagnostics$, "_cachedBuilder");
  const _is_DiagnosticableNode_default = Symbol('_is_DiagnosticableNode_default');
  diagnostics$.DiagnosticableNode$ = dart.generic(T => {
    class DiagnosticableNode extends diagnostics$.DiagnosticsNode {
      get value() {
        return this[value$];
      }
      set value(value) {
        super.value = value;
      }
      get builder() {
        if (false) {
          return null;
        } else {
          if (!dart.test(dart.fn(() => {
            if (this[_cachedBuilder] == null) {
              this[_cachedBuilder] = new diagnostics$.DiagnosticPropertiesBuilder.new();
              this.value.debugFillProperties(dart.nullCheck(this[_cachedBuilder]));
            }
            return true;
          }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 2942, 14, "() {\r\n        if (_cachedBuilder == null) {\r\n          _cachedBuilder = DiagnosticPropertiesBuilder();\r\n          value.debugFillProperties(_cachedBuilder!);\r\n        }\r\n        return true;\r\n      }()");
          return this[_cachedBuilder];
        }
      }
      get style() {
        let t8;
        return false ? diagnostics$.DiagnosticsTreeStyle.none : (t8 = super.style, t8 == null ? dart.nullCheck(this.builder).defaultDiagnosticsTreeStyle : t8);
      }
      get emptyBodyDescription() {
        return false || false ? "" : dart.nullCheck(this.builder).emptyBodyDescription;
      }
      getProperties() {
        return false || false ? C[31] || CT.C31 : dart.nullCheck(this.builder).properties;
      }
      getChildren() {
        return C[31] || CT.C31;
      }
      toDescription(opts) {
        let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
        let result = "";
        if (!dart.test(dart.fn(() => {
          result = this.value.toStringShort();
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 2972, 12, "() {\r\n      result = value.toStringShort();\r\n      return true;\r\n    }()");
        return result;
      }
    }
    (DiagnosticableNode.new = function(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let value = opts && 'value' in opts ? opts.value : null;
      if (value == null) dart.nullFailed(I[1], 2922, 19, "value");
      let style = opts && 'style' in opts ? opts.style : null;
      this[_cachedBuilder] = null;
      this[value$] = value;
      if (!(value != null)) dart.assertFailed(null, I[1], 2924, 15, "value != null");
      DiagnosticableNode.__proto__.new.call(this, {name: name, style: style});
      ;
    }).prototype = DiagnosticableNode.prototype;
    dart.addTypeTests(DiagnosticableNode);
    DiagnosticableNode.prototype[_is_DiagnosticableNode_default] = true;
    dart.addTypeCaches(DiagnosticableNode);
    dart.setMethodSignature(DiagnosticableNode, () => ({
      __proto__: dart.getMethods(DiagnosticableNode.__proto__),
      getProperties: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), []),
      getChildren: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), []),
      toDescription: dart.fnType(core.String, [], {parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)}, {})
    }));
    dart.setGetterSignature(DiagnosticableNode, () => ({
      __proto__: dart.getGetters(DiagnosticableNode.__proto__),
      builder: dart.nullable(diagnostics$.DiagnosticPropertiesBuilder),
      style: diagnostics$.DiagnosticsTreeStyle
    }));
    dart.setLibraryUri(DiagnosticableNode, I[2]);
    dart.setFieldSignature(DiagnosticableNode, () => ({
      __proto__: dart.getFields(DiagnosticableNode.__proto__),
      value: dart.finalFieldType(T),
      [_cachedBuilder]: dart.fieldType(dart.nullable(diagnostics$.DiagnosticPropertiesBuilder))
    }));
    return DiagnosticableNode;
  });
  diagnostics$.DiagnosticableNode = diagnostics$.DiagnosticableNode$();
  dart.addTypeTests(diagnostics$.DiagnosticableNode, _is_DiagnosticableNode_default);
  diagnostics$.Diagnosticable = class Diagnosticable extends core.Object {};
  diagnostics$.Diagnosticable[dart.mixinOn] = Object => {
    class Diagnosticable extends Object {
      toStringShort() {
        return diagnostics$.describeIdentity(this);
      }
      toString(opts) {
        let t8;
        let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[5] || CT.C5;
        if (minLevel == null) dart.nullFailed(I[1], 3107, 37, "minLevel");
        let fullString = null;
        if (!dart.test(dart.fn(() => {
          fullString = this.toDiagnosticsNode({style: diagnostics$.DiagnosticsTreeStyle.singleLine}).toString({minLevel: minLevel});
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 3109, 12, "() {\r\n      fullString = toDiagnosticsNode(style: DiagnosticsTreeStyle.singleLine).toString(minLevel: minLevel);\r\n      return true;\r\n    }()");
        t8 = fullString;
        return t8 == null ? this.toStringShort() : t8;
      }
      toDiagnosticsNode(opts) {
        let name = opts && 'name' in opts ? opts.name : null;
        let style = opts && 'style' in opts ? opts.style : null;
        return new (T$.DiagnosticableNodeOfDiagnosticable()).new({name: name, value: this, style: style});
      }
      debugFillProperties(properties) {
        if (properties == null) dart.nullFailed(I[1], 3342, 56, "properties");
      }
    }
    dart.defineExtensionMethods(Diagnosticable, ['toString']);
    return Diagnosticable;
  };
  (diagnostics$.Diagnosticable[dart.mixinNew] = function() {
  }).prototype = diagnostics$.Diagnosticable.prototype;
  dart.addTypeTests(diagnostics$.Diagnosticable);
  dart.addTypeCaches(diagnostics$.Diagnosticable);
  diagnostics$.Diagnosticable[dart.implements] = () => [core.Object];
  dart.setMethodSignature(diagnostics$.Diagnosticable, () => ({
    __proto__: dart.getMethods(diagnostics$.Diagnosticable.__proto__),
    toStringShort: dart.fnType(core.String, []),
    toString: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel}, {}),
    [$toString]: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel}, {}),
    toDiagnosticsNode: dart.fnType(diagnostics$.DiagnosticsNode, [], {name: dart.nullable(core.String), style: dart.nullable(diagnostics$.DiagnosticsTreeStyle)}, {}),
    debugFillProperties: dart.fnType(dart.void, [diagnostics$.DiagnosticPropertiesBuilder])
  }));
  dart.setLibraryUri(diagnostics$.Diagnosticable, I[2]);
  const Object_Diagnosticable$36 = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36.new = function() {
  }).prototype = Object_Diagnosticable$36.prototype;
  dart.applyMixin(Object_Diagnosticable$36, diagnostics$.Diagnosticable);
  diagnostics$.DiagnosticableTree = class DiagnosticableTree extends Object_Diagnosticable$36 {
    toStringShallow(opts) {
      let t8;
      let joiner = opts && 'joiner' in opts ? opts.joiner : ", ";
      if (joiner == null) dart.nullFailed(I[1], 3381, 12, "joiner");
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[4] || CT.C4;
      if (minLevel == null) dart.nullFailed(I[1], 3382, 21, "minLevel");
      let shallowString = null;
      if (!dart.test(dart.fn(() => {
        let result = new core.StringBuffer.new();
        result.write(this.toString());
        result.write(joiner);
        let builder = new diagnostics$.DiagnosticPropertiesBuilder.new();
        this.debugFillProperties(builder);
        result.write(builder.properties[$where](dart.fn(n => {
          if (n == null) dart.nullFailed(I[1], 3392, 51, "n");
          return !dart.test(n.isFiltered(minLevel));
        }, T$.DiagnosticsNodeTobool()))[$join](joiner));
        shallowString = result.toString();
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 3385, 12, "() {\r\n      final StringBuffer result = StringBuffer();\r\n      result.write(toString());\r\n      result.write(joiner);\r\n      final DiagnosticPropertiesBuilder builder = DiagnosticPropertiesBuilder();\r\n      debugFillProperties(builder);\r\n      result.write(\r\n        builder.properties.where((DiagnosticsNode n) => !n.isFiltered(minLevel))\r\n            .join(joiner),\r\n      );\r\n      shallowString = result.toString();\r\n      return true;\r\n    }()");
      t8 = shallowString;
      return t8 == null ? this.toString() : t8;
    }
    toStringDeep(opts) {
      let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : "";
      if (prefixLineOne == null) dart.nullFailed(I[1], 3420, 12, "prefixLineOne");
      let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[4] || CT.C4;
      if (minLevel == null) dart.nullFailed(I[1], 3422, 21, "minLevel");
      return this.toDiagnosticsNode().toStringDeep({prefixLineOne: prefixLineOne, prefixOtherLines: prefixOtherLines, minLevel: minLevel});
    }
    toStringShort() {
      return diagnostics$.describeIdentity(this);
    }
    toDiagnosticsNode(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let style = opts && 'style' in opts ? opts.style : null;
      return new diagnostics$.DiagnosticableTreeNode.new({name: name, value: this, style: style});
    }
    debugDescribeChildren() {
      return C[31] || CT.C31;
    }
  };
  (diagnostics$.DiagnosticableTree.new = function() {
    ;
  }).prototype = diagnostics$.DiagnosticableTree.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticableTree);
  dart.addTypeCaches(diagnostics$.DiagnosticableTree);
  dart.setMethodSignature(diagnostics$.DiagnosticableTree, () => ({
    __proto__: dart.getMethods(diagnostics$.DiagnosticableTree.__proto__),
    toStringShallow: dart.fnType(core.String, [], {joiner: core.String, minLevel: diagnostics$.DiagnosticLevel}, {}),
    toStringDeep: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel, prefixLineOne: core.String, prefixOtherLines: dart.nullable(core.String)}, {}),
    debugDescribeChildren: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), [])
  }));
  dart.setLibraryUri(diagnostics$.DiagnosticableTree, I[2]);
  diagnostics$.DiagnosticableTreeNode = class DiagnosticableTreeNode extends diagnostics$.DiagnosticableNode$(diagnostics$.DiagnosticableTree) {
    getChildren() {
      return this.value.debugDescribeChildren();
    }
  };
  (diagnostics$.DiagnosticableTreeNode.new = function(opts) {
    let name = opts && 'name' in opts ? opts.name : null;
    let value = opts && 'value' in opts ? opts.value : null;
    if (value == null) dart.nullFailed(I[1], 2985, 33, "value");
    let style = opts && 'style' in opts ? opts.style : null;
    diagnostics$.DiagnosticableTreeNode.__proto__.new.call(this, {name: name, value: value, style: style});
    ;
  }).prototype = diagnostics$.DiagnosticableTreeNode.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticableTreeNode);
  dart.addTypeCaches(diagnostics$.DiagnosticableTreeNode);
  dart.setLibraryUri(diagnostics$.DiagnosticableTreeNode, I[2]);
  var properties$ = dart.privateName(diagnostics$, "DiagnosticPropertiesBuilder.properties");
  var defaultDiagnosticsTreeStyle = dart.privateName(diagnostics$, "DiagnosticPropertiesBuilder.defaultDiagnosticsTreeStyle");
  var emptyBodyDescription = dart.privateName(diagnostics$, "DiagnosticPropertiesBuilder.emptyBodyDescription");
  diagnostics$.DiagnosticPropertiesBuilder = class DiagnosticPropertiesBuilder extends core.Object {
    get properties() {
      return this[properties$];
    }
    set properties(value) {
      super.properties = value;
    }
    get defaultDiagnosticsTreeStyle() {
      return this[defaultDiagnosticsTreeStyle];
    }
    set defaultDiagnosticsTreeStyle(value) {
      this[defaultDiagnosticsTreeStyle] = value;
    }
    get emptyBodyDescription() {
      return this[emptyBodyDescription];
    }
    set emptyBodyDescription(value) {
      this[emptyBodyDescription] = value;
    }
    add(property) {
      if (property == null) dart.nullFailed(I[1], 3053, 28, "property");
      if (!dart.test(dart.fn(() => {
        this.properties[$add](property);
        return true;
      }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 3054, 12, "() {\r\n      properties.add(property);\r\n      return true;\r\n    }()");
    }
  };
  (diagnostics$.DiagnosticPropertiesBuilder.new = function() {
    this[defaultDiagnosticsTreeStyle] = diagnostics$.DiagnosticsTreeStyle.sparse;
    this[emptyBodyDescription] = null;
    this[properties$] = T$.JSArrayOfDiagnosticsNode().of([]);
    ;
  }).prototype = diagnostics$.DiagnosticPropertiesBuilder.prototype;
  (diagnostics$.DiagnosticPropertiesBuilder.fromProperties = function(properties) {
    if (properties == null) dart.nullFailed(I[1], 3050, 51, "properties");
    this[defaultDiagnosticsTreeStyle] = diagnostics$.DiagnosticsTreeStyle.sparse;
    this[emptyBodyDescription] = null;
    this[properties$] = properties;
    ;
  }).prototype = diagnostics$.DiagnosticPropertiesBuilder.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticPropertiesBuilder);
  dart.addTypeCaches(diagnostics$.DiagnosticPropertiesBuilder);
  dart.setMethodSignature(diagnostics$.DiagnosticPropertiesBuilder, () => ({
    __proto__: dart.getMethods(diagnostics$.DiagnosticPropertiesBuilder.__proto__),
    add: dart.fnType(dart.void, [diagnostics$.DiagnosticsNode])
  }));
  dart.setLibraryUri(diagnostics$.DiagnosticPropertiesBuilder, I[2]);
  dart.setFieldSignature(diagnostics$.DiagnosticPropertiesBuilder, () => ({
    __proto__: dart.getFields(diagnostics$.DiagnosticPropertiesBuilder.__proto__),
    properties: dart.finalFieldType(core.List$(diagnostics$.DiagnosticsNode)),
    defaultDiagnosticsTreeStyle: dart.fieldType(diagnostics$.DiagnosticsTreeStyle),
    emptyBodyDescription: dart.fieldType(dart.nullable(core.String))
  }));
  diagnostics$.DiagnosticableTreeMixin = class DiagnosticableTreeMixin extends core.Object {};
  diagnostics$.DiagnosticableTreeMixin[dart.mixinOn] = Object => {
    class DiagnosticableTreeMixin extends Object {
      toString(opts) {
        let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[5] || CT.C5;
        if (minLevel == null) dart.nullFailed(I[1], 3465, 37, "minLevel");
        return this.toDiagnosticsNode({style: diagnostics$.DiagnosticsTreeStyle.singleLine}).toString({minLevel: minLevel});
      }
      toStringShallow(opts) {
        let t8;
        let joiner = opts && 'joiner' in opts ? opts.joiner : ", ";
        if (joiner == null) dart.nullFailed(I[1], 3471, 12, "joiner");
        let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[4] || CT.C4;
        if (minLevel == null) dart.nullFailed(I[1], 3472, 21, "minLevel");
        let shallowString = null;
        if (!dart.test(dart.fn(() => {
          let result = new core.StringBuffer.new();
          result.write(this.toStringShort());
          result.write(joiner);
          let builder = new diagnostics$.DiagnosticPropertiesBuilder.new();
          this.debugFillProperties(builder);
          result.write(builder.properties[$where](dart.fn(n => {
            if (n == null) dart.nullFailed(I[1], 3482, 51, "n");
            return !dart.test(n.isFiltered(minLevel));
          }, T$.DiagnosticsNodeTobool()))[$join](joiner));
          shallowString = result.toString();
          return true;
        }, T$.VoidTobool())())) dart.assertFailed(null, I[1], 3475, 12, "() {\r\n      final StringBuffer result = StringBuffer();\r\n      result.write(toStringShort());\r\n      result.write(joiner);\r\n      final DiagnosticPropertiesBuilder builder = DiagnosticPropertiesBuilder();\r\n      debugFillProperties(builder);\r\n      result.write(\r\n        builder.properties.where((DiagnosticsNode n) => !n.isFiltered(minLevel))\r\n            .join(joiner),\r\n      );\r\n      shallowString = result.toString();\r\n      return true;\r\n    }()");
        t8 = shallowString;
        return t8 == null ? this.toString() : t8;
      }
      toStringDeep(opts) {
        let prefixLineOne = opts && 'prefixLineOne' in opts ? opts.prefixLineOne : "";
        if (prefixLineOne == null) dart.nullFailed(I[1], 3493, 12, "prefixLineOne");
        let prefixOtherLines = opts && 'prefixOtherLines' in opts ? opts.prefixOtherLines : null;
        let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[4] || CT.C4;
        if (minLevel == null) dart.nullFailed(I[1], 3495, 21, "minLevel");
        return this.toDiagnosticsNode().toStringDeep({prefixLineOne: prefixLineOne, prefixOtherLines: prefixOtherLines, minLevel: minLevel});
      }
      toStringShort() {
        return diagnostics$.describeIdentity(this);
      }
      toDiagnosticsNode(opts) {
        let name = opts && 'name' in opts ? opts.name : null;
        let style = opts && 'style' in opts ? opts.style : null;
        return new diagnostics$.DiagnosticableTreeNode.new({name: name, value: this, style: style});
      }
      debugDescribeChildren() {
        return C[31] || CT.C31;
      }
      debugFillProperties(properties) {
        if (properties == null) dart.nullFailed(I[1], 3516, 56, "properties");
      }
    }
    dart.defineExtensionMethods(DiagnosticableTreeMixin, ['toString']);
    return DiagnosticableTreeMixin;
  };
  (diagnostics$.DiagnosticableTreeMixin[dart.mixinNew] = function() {
  }).prototype = diagnostics$.DiagnosticableTreeMixin.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticableTreeMixin);
  dart.addTypeCaches(diagnostics$.DiagnosticableTreeMixin);
  diagnostics$.DiagnosticableTreeMixin[dart.implements] = () => [diagnostics$.DiagnosticableTree, core.Object];
  dart.setMethodSignature(diagnostics$.DiagnosticableTreeMixin, () => ({
    __proto__: dart.getMethods(diagnostics$.DiagnosticableTreeMixin.__proto__),
    toString: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel}, {}),
    [$toString]: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel}, {}),
    toStringShallow: dart.fnType(core.String, [], {joiner: core.String, minLevel: diagnostics$.DiagnosticLevel}, {}),
    toStringDeep: dart.fnType(core.String, [], {minLevel: diagnostics$.DiagnosticLevel, prefixLineOne: core.String, prefixOtherLines: dart.nullable(core.String)}, {}),
    toStringShort: dart.fnType(core.String, []),
    toDiagnosticsNode: dart.fnType(diagnostics$.DiagnosticsNode, [], {name: dart.nullable(core.String), style: dart.nullable(diagnostics$.DiagnosticsTreeStyle)}, {}),
    debugDescribeChildren: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), []),
    debugFillProperties: dart.fnType(dart.void, [diagnostics$.DiagnosticPropertiesBuilder])
  }));
  dart.setLibraryUri(diagnostics$.DiagnosticableTreeMixin, I[2]);
  var level$ = dart.privateName(diagnostics$, "DiagnosticsBlock.level");
  var value$0 = dart.privateName(diagnostics$, "DiagnosticsBlock.value");
  var allowTruncate$ = dart.privateName(diagnostics$, "DiagnosticsBlock.allowTruncate");
  var _children = dart.privateName(diagnostics$, "_children");
  var _properties = dart.privateName(diagnostics$, "_properties");
  diagnostics$.DiagnosticsBlock = class DiagnosticsBlock extends diagnostics$.DiagnosticsNode {
    get level() {
      return this[level$];
    }
    set level(value) {
      super.level = value;
    }
    get value() {
      return this[value$0];
    }
    set value(value) {
      super.value = value;
    }
    get allowTruncate() {
      return this[allowTruncate$];
    }
    set allowTruncate(value) {
      super.allowTruncate = value;
    }
    getChildren() {
      return this[_children];
    }
    getProperties() {
      return this[_properties];
    }
    toDescription(opts) {
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      return this[_description];
    }
  };
  (diagnostics$.DiagnosticsBlock.new = function(opts) {
    let name = opts && 'name' in opts ? opts.name : null;
    let style = opts && 'style' in opts ? opts.style : C[18] || CT.C18;
    if (style == null) dart.nullFailed(I[1], 3529, 26, "style");
    let showName = opts && 'showName' in opts ? opts.showName : true;
    if (showName == null) dart.nullFailed(I[1], 3530, 10, "showName");
    let showSeparator = opts && 'showSeparator' in opts ? opts.showSeparator : true;
    if (showSeparator == null) dart.nullFailed(I[1], 3531, 10, "showSeparator");
    let linePrefix = opts && 'linePrefix' in opts ? opts.linePrefix : null;
    let value = opts && 'value' in opts ? opts.value : null;
    let description = opts && 'description' in opts ? opts.description : null;
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[1], 3535, 10, "level");
    let allowTruncate = opts && 'allowTruncate' in opts ? opts.allowTruncate : false;
    if (allowTruncate == null) dart.nullFailed(I[1], 3536, 10, "allowTruncate");
    let children = opts && 'children' in opts ? opts.children : C[31] || CT.C31;
    if (children == null) dart.nullFailed(I[1], 3537, 27, "children");
    let properties = opts && 'properties' in opts ? opts.properties : C[31] || CT.C31;
    if (properties == null) dart.nullFailed(I[1], 3538, 27, "properties");
    this[value$0] = value;
    this[level$] = level;
    this[allowTruncate$] = allowTruncate;
    this[_description] = description;
    this[_children] = children;
    this[_properties] = properties;
    diagnostics$.DiagnosticsBlock.__proto__.new.call(this, {name: name, style: style, showName: dart.test(showName) && name != null, showSeparator: showSeparator, linePrefix: linePrefix});
    ;
  }).prototype = diagnostics$.DiagnosticsBlock.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticsBlock);
  dart.addTypeCaches(diagnostics$.DiagnosticsBlock);
  dart.setMethodSignature(diagnostics$.DiagnosticsBlock, () => ({
    __proto__: dart.getMethods(diagnostics$.DiagnosticsBlock.__proto__),
    getChildren: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), []),
    getProperties: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), []),
    toDescription: dart.fnType(dart.nullable(core.String), [], {parentConfiguration: dart.nullable(diagnostics$.TextTreeConfiguration)}, {})
  }));
  dart.setLibraryUri(diagnostics$.DiagnosticsBlock, I[2]);
  dart.setFieldSignature(diagnostics$.DiagnosticsBlock, () => ({
    __proto__: dart.getFields(diagnostics$.DiagnosticsBlock.__proto__),
    [_children]: dart.finalFieldType(core.List$(diagnostics$.DiagnosticsNode)),
    [_properties]: dart.finalFieldType(core.List$(diagnostics$.DiagnosticsNode)),
    level: dart.finalFieldType(diagnostics$.DiagnosticLevel),
    [_description]: dart.finalFieldType(dart.nullable(core.String)),
    value: dart.finalFieldType(dart.nullable(core.Object)),
    allowTruncate: dart.finalFieldType(core.bool)
  }));
  diagnostics$.DiagnosticsSerializationDelegate = class DiagnosticsSerializationDelegate extends core.Object {};
  (diagnostics$.DiagnosticsSerializationDelegate[dart.mixinNew] = function() {
  }).prototype = diagnostics$.DiagnosticsSerializationDelegate.prototype;
  dart.addTypeTests(diagnostics$.DiagnosticsSerializationDelegate);
  dart.addTypeCaches(diagnostics$.DiagnosticsSerializationDelegate);
  dart.setLibraryUri(diagnostics$.DiagnosticsSerializationDelegate, I[2]);
  var includeProperties$ = dart.privateName(diagnostics$, "_DefaultDiagnosticsSerializationDelegate.includeProperties");
  var subtreeDepth$ = dart.privateName(diagnostics$, "_DefaultDiagnosticsSerializationDelegate.subtreeDepth");
  diagnostics$._DefaultDiagnosticsSerializationDelegate = class _DefaultDiagnosticsSerializationDelegate extends core.Object {
    get includeProperties() {
      return this[includeProperties$];
    }
    set includeProperties(value) {
      super.includeProperties = value;
    }
    get subtreeDepth() {
      return this[subtreeDepth$];
    }
    set subtreeDepth(value) {
      super.subtreeDepth = value;
    }
    additionalNodeProperties(node) {
      if (node == null) dart.nullFailed(I[1], 3686, 65, "node");
      return C[32] || CT.C32;
    }
    delegateForNode(node) {
      if (node == null) dart.nullFailed(I[1], 3691, 68, "node");
      return dart.notNull(this.subtreeDepth) > 0 ? this.copyWith({subtreeDepth: dart.notNull(this.subtreeDepth) - 1}) : this;
    }
    get expandPropertyValues() {
      return false;
    }
    filterChildren(nodes, owner) {
      if (nodes == null) dart.nullFailed(I[1], 3699, 62, "nodes");
      if (owner == null) dart.nullFailed(I[1], 3699, 85, "owner");
      return nodes;
    }
    filterProperties(nodes, owner) {
      if (nodes == null) dart.nullFailed(I[1], 3704, 64, "nodes");
      if (owner == null) dart.nullFailed(I[1], 3704, 87, "owner");
      return nodes;
    }
    truncateNodesList(nodes, owner) {
      if (nodes == null) dart.nullFailed(I[1], 3715, 65, "nodes");
      return nodes;
    }
    copyWith(opts) {
      let t8, t8$;
      let subtreeDepth = opts && 'subtreeDepth' in opts ? opts.subtreeDepth : null;
      let includeProperties = opts && 'includeProperties' in opts ? opts.includeProperties : null;
      return new diagnostics$._DefaultDiagnosticsSerializationDelegate.new({subtreeDepth: (t8 = subtreeDepth, t8 == null ? this.subtreeDepth : t8), includeProperties: (t8$ = includeProperties, t8$ == null ? this.includeProperties : t8$)});
    }
  };
  (diagnostics$._DefaultDiagnosticsSerializationDelegate.new = function(opts) {
    let includeProperties = opts && 'includeProperties' in opts ? opts.includeProperties : false;
    if (includeProperties == null) dart.nullFailed(I[1], 3681, 10, "includeProperties");
    let subtreeDepth = opts && 'subtreeDepth' in opts ? opts.subtreeDepth : 0;
    if (subtreeDepth == null) dart.nullFailed(I[1], 3682, 10, "subtreeDepth");
    this[includeProperties$] = includeProperties;
    this[subtreeDepth$] = subtreeDepth;
    ;
  }).prototype = diagnostics$._DefaultDiagnosticsSerializationDelegate.prototype;
  dart.addTypeTests(diagnostics$._DefaultDiagnosticsSerializationDelegate);
  dart.addTypeCaches(diagnostics$._DefaultDiagnosticsSerializationDelegate);
  diagnostics$._DefaultDiagnosticsSerializationDelegate[dart.implements] = () => [diagnostics$.DiagnosticsSerializationDelegate];
  dart.setMethodSignature(diagnostics$._DefaultDiagnosticsSerializationDelegate, () => ({
    __proto__: dart.getMethods(diagnostics$._DefaultDiagnosticsSerializationDelegate.__proto__),
    additionalNodeProperties: dart.fnType(core.Map$(core.String, dart.nullable(core.Object)), [diagnostics$.DiagnosticsNode]),
    delegateForNode: dart.fnType(diagnostics$.DiagnosticsSerializationDelegate, [diagnostics$.DiagnosticsNode]),
    filterChildren: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), [core.List$(diagnostics$.DiagnosticsNode), diagnostics$.DiagnosticsNode]),
    filterProperties: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), [core.List$(diagnostics$.DiagnosticsNode), diagnostics$.DiagnosticsNode]),
    truncateNodesList: dart.fnType(core.List$(diagnostics$.DiagnosticsNode), [core.List$(diagnostics$.DiagnosticsNode), dart.nullable(diagnostics$.DiagnosticsNode)]),
    copyWith: dart.fnType(diagnostics$.DiagnosticsSerializationDelegate, [], {includeProperties: dart.nullable(core.bool), subtreeDepth: dart.nullable(core.int)}, {})
  }));
  dart.setGetterSignature(diagnostics$._DefaultDiagnosticsSerializationDelegate, () => ({
    __proto__: dart.getGetters(diagnostics$._DefaultDiagnosticsSerializationDelegate.__proto__),
    expandPropertyValues: core.bool
  }));
  dart.setLibraryUri(diagnostics$._DefaultDiagnosticsSerializationDelegate, I[2]);
  dart.setFieldSignature(diagnostics$._DefaultDiagnosticsSerializationDelegate, () => ({
    __proto__: dart.getFields(diagnostics$._DefaultDiagnosticsSerializationDelegate.__proto__),
    includeProperties: dart.finalFieldType(core.bool),
    subtreeDepth: dart.finalFieldType(core.int)
  }));
  diagnostics$._isSingleLine = function _isSingleLine(style) {
    return style == diagnostics$.DiagnosticsTreeStyle.singleLine;
  };
  diagnostics$.shortHash = function shortHash(object) {
    return dart.hashCode(object)[$toUnsigned](20)[$toRadixString](16)[$padLeft](5, "0");
  };
  diagnostics$.describeIdentity = function describeIdentity(object) {
    return dart.str(object$.objectRuntimeType(object, "<optimized out>")) + "#" + dart.str(diagnostics$.shortHash(object));
  };
  diagnostics$.describeEnum = function describeEnum(enumEntry) {
    if (enumEntry == null) dart.nullFailed(I[1], 3032, 28, "enumEntry");
    let description = dart.toString(enumEntry);
    let indexOfDot = description[$indexOf](".");
    if (!(indexOfDot !== -1 && indexOfDot < description.length - 1)) dart.assertFailed("The provided object \"" + dart.str(enumEntry) + "\" is not an enum.", I[1], 3036, 5, "indexOfDot != -1 && indexOfDot < description.length - 1");
    return description[$substring](indexOfDot + 1);
  };
  dart.defineLazy(diagnostics$, {
    /*diagnostics$.sparseTextConfiguration*/get sparseTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: "", prefixOtherLines: " ", prefixLastChildLineOne: "", linkCharacter: "", propertyPrefixIfChildren: " ", propertyPrefixNoChildren: "  ", prefixOtherLinesRootNode: " "});
    },
    /*diagnostics$.dashedTextConfiguration*/get dashedTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: "", prefixLastChildLineOne: "", prefixOtherLines: " ", linkCharacter: "", propertyPrefixIfChildren: " ", propertyPrefixNoChildren: "  ", prefixOtherLinesRootNode: " "});
    },
    /*diagnostics$.denseTextConfiguration*/get denseTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({propertySeparator: ", ", beforeProperties: "(", afterProperties: ")", lineBreakProperties: false, prefixLineOne: "", prefixOtherLines: "", prefixLastChildLineOne: "", linkCharacter: "", propertyPrefixIfChildren: "", propertyPrefixNoChildren: " ", prefixOtherLinesRootNode: "", addBlankLineIfNoChildren: false, isBlankLineBetweenPropertiesAndChildren: false});
    },
    /*diagnostics$.transitionTextConfiguration*/get transitionTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: " ", prefixLastChildLineOne: " ", prefixOtherLines: "  ", footer: " ", linkCharacter: "", propertyPrefixIfChildren: "", propertyPrefixNoChildren: "", prefixOtherLinesRootNode: "", afterName: " ", afterDescriptionIfBody: ":", bodyIndent: "  ", isNameOnOwnLine: true, addBlankLineIfNoChildren: false, isBlankLineBetweenPropertiesAndChildren: false});
    },
    /*diagnostics$.errorTextConfiguration*/get errorTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: "", prefixLastChildLineOne: "", prefixOtherLines: "  ", footer: " ", linkCharacter: "", propertyPrefixIfChildren: "", propertyPrefixNoChildren: "", prefixOtherLinesRootNode: "", beforeName: " ", suffixLineOne: " ", mandatoryFooter: "", addBlankLineIfNoChildren: false, isBlankLineBetweenPropertiesAndChildren: false});
    },
    /*diagnostics$.whitespaceTextConfiguration*/get whitespaceTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: "", prefixLastChildLineOne: "", prefixOtherLines: " ", prefixOtherLinesRootNode: "  ", bodyIndent: "", propertyPrefixIfChildren: "", propertyPrefixNoChildren: "", linkCharacter: " ", addBlankLineIfNoChildren: false, afterDescriptionIfBody: ":", isBlankLineBetweenPropertiesAndChildren: false});
    },
    /*diagnostics$.flatTextConfiguration*/get flatTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: "", prefixLastChildLineOne: "", prefixOtherLines: "", prefixOtherLinesRootNode: "", bodyIndent: "", propertyPrefixIfChildren: "", propertyPrefixNoChildren: "", linkCharacter: "", addBlankLineIfNoChildren: false, afterDescriptionIfBody: ":", isBlankLineBetweenPropertiesAndChildren: false});
    },
    /*diagnostics$.singleLineTextConfiguration*/get singleLineTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({propertySeparator: ", ", beforeProperties: "(", afterProperties: ")", prefixLineOne: "", prefixOtherLines: "", prefixLastChildLineOne: "", lineBreak: "", lineBreakProperties: false, addBlankLineIfNoChildren: false, showChildren: false, propertyPrefixIfChildren: "  ", propertyPrefixNoChildren: "  ", linkCharacter: "", prefixOtherLinesRootNode: ""});
    },
    /*diagnostics$.errorPropertyTextConfiguration*/get errorPropertyTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({propertySeparator: ", ", beforeProperties: "(", afterProperties: ")", prefixLineOne: "", prefixOtherLines: "", prefixLastChildLineOne: "", lineBreak: "\n", lineBreakProperties: false, addBlankLineIfNoChildren: false, showChildren: false, propertyPrefixIfChildren: "  ", propertyPrefixNoChildren: "  ", linkCharacter: "", prefixOtherLinesRootNode: "", afterName: ":", isNameOnOwnLine: true});
    },
    /*diagnostics$.shallowTextConfiguration*/get shallowTextConfiguration() {
      return new diagnostics$.TextTreeConfiguration.new({prefixLineOne: "", prefixLastChildLineOne: "", prefixOtherLines: " ", prefixOtherLinesRootNode: "  ", bodyIndent: "", propertyPrefixIfChildren: "", propertyPrefixNoChildren: "", linkCharacter: " ", addBlankLineIfNoChildren: false, afterDescriptionIfBody: ":", isBlankLineBetweenPropertiesAndChildren: false, showChildren: false});
    },
    /*diagnostics$.kNoDefaultValue*/get kNoDefaultValue() {
      return C[30] || CT.C30;
    }
  }, false);
  var $package$ = dart.privateName(assertions, "PartialStackFrame.package");
  var className$ = dart.privateName(assertions, "PartialStackFrame.className");
  var method$ = dart.privateName(assertions, "PartialStackFrame.method");
  assertions.PartialStackFrame = class PartialStackFrame extends core.Object {
    get package() {
      return this[$package$];
    }
    set package(value) {
      super.package = value;
    }
    get className() {
      return this[className$];
    }
    set className(value) {
      super.className = value;
    }
    get method() {
      return this[method$];
    }
    set method(value) {
      super.method = value;
    }
    matches(stackFrame) {
      if (stackFrame == null) dart.nullFailed(I[3], 79, 27, "stackFrame");
      let stackFramePackage = dart.str(stackFrame.packageScheme) + ":" + dart.str(stackFrame.package) + "/" + dart.str(stackFrame.packagePath);
      if (true) {
        return dart.test(this.package[$allMatches](stackFramePackage)[$isNotEmpty]) && stackFrame.method == (this.method[$startsWith]("_") ? "[" + dart.str(this.method) + "]" : this.method);
      }
      return dart.test(this.package[$allMatches](stackFramePackage)[$isNotEmpty]) && stackFrame.method == this.method && stackFrame.className == this.className;
    }
  };
  (assertions.PartialStackFrame.new = function(opts) {
    let $package = opts && 'package' in opts ? opts.package : null;
    if ($package == null) dart.nullFailed(I[3], 47, 19, "package");
    let className = opts && 'className' in opts ? opts.className : null;
    if (className == null) dart.nullFailed(I[3], 48, 19, "className");
    let method = opts && 'method' in opts ? opts.method : null;
    if (method == null) dart.nullFailed(I[3], 49, 19, "method");
    this[$package$] = $package;
    this[className$] = className;
    this[method$] = method;
    if (!(className != null)) dart.assertFailed(null, I[3], 50, 15, "className != null");
    if (!(method != null)) dart.assertFailed(null, I[3], 51, 15, "method != null");
    if (!($package != null)) dart.assertFailed(null, I[3], 52, 15, "package != null");
    ;
  }).prototype = assertions.PartialStackFrame.prototype;
  dart.addTypeTests(assertions.PartialStackFrame);
  dart.addTypeCaches(assertions.PartialStackFrame);
  dart.setMethodSignature(assertions.PartialStackFrame, () => ({
    __proto__: dart.getMethods(assertions.PartialStackFrame.__proto__),
    matches: dart.fnType(core.bool, [stack_frame.StackFrame])
  }));
  dart.setLibraryUri(assertions.PartialStackFrame, I[4]);
  dart.setFieldSignature(assertions.PartialStackFrame, () => ({
    __proto__: dart.getFields(assertions.PartialStackFrame.__proto__),
    package: dart.finalFieldType(core.Pattern),
    className: dart.finalFieldType(core.String),
    method: dart.finalFieldType(core.String)
  }));
  dart.defineLazy(assertions.PartialStackFrame, {
    /*assertions.PartialStackFrame.asynchronousSuspension*/get asynchronousSuspension() {
      return C[33] || CT.C33;
    }
  }, false);
  assertions.StackFilter = class StackFilter extends core.Object {};
  (assertions.StackFilter.new = function() {
    ;
  }).prototype = assertions.StackFilter.prototype;
  dart.addTypeTests(assertions.StackFilter);
  dart.addTypeCaches(assertions.StackFilter);
  dart.setLibraryUri(assertions.StackFilter, I[4]);
  var frames$ = dart.privateName(assertions, "RepetitiveStackFrameFilter.frames");
  var replacement$ = dart.privateName(assertions, "RepetitiveStackFrameFilter.replacement");
  var _replacements = dart.privateName(assertions, "_replacements");
  var _matchesFrames = dart.privateName(assertions, "_matchesFrames");
  assertions.RepetitiveStackFrameFilter = class RepetitiveStackFrameFilter extends assertions.StackFilter {
    get frames() {
      return this[frames$];
    }
    set frames(value) {
      super.frames = value;
    }
    get replacement() {
      return this[replacement$];
    }
    set replacement(value) {
      super.replacement = value;
    }
    get numFrames() {
      return this.frames[$length];
    }
    get [_replacements]() {
      return T$.ListOfString().filled(this.numFrames, this.replacement);
    }
    filter(stackFrames, reasons) {
      if (stackFrames == null) dart.nullFailed(I[3], 142, 32, "stackFrames");
      if (reasons == null) dart.nullFailed(I[3], 142, 59, "reasons");
      for (let index = 0; index < dart.notNull(stackFrames[$length]) - dart.notNull(this.numFrames); index = index + 1) {
        if (dart.test(this[_matchesFrames](stackFrames[$skip](index)[$take](this.numFrames)[$toList]()))) {
          reasons[$setRange](index, index + dart.notNull(this.numFrames), this[_replacements]);
          index = index + (dart.notNull(this.numFrames) - 1);
        }
      }
    }
    [_matchesFrames](stackFrames) {
      if (stackFrames == null) dart.nullFailed(I[3], 151, 40, "stackFrames");
      if (dart.notNull(stackFrames[$length]) < dart.notNull(this.numFrames)) {
        return false;
      }
      for (let index = 0; index < dart.notNull(stackFrames[$length]); index = index + 1) {
        if (!dart.test(this.frames[$_get](index).matches(stackFrames[$_get](index)))) {
          return false;
        }
      }
      return true;
    }
  };
  (assertions.RepetitiveStackFrameFilter.new = function(opts) {
    let frames = opts && 'frames' in opts ? opts.frames : null;
    if (frames == null) dart.nullFailed(I[3], 121, 19, "frames");
    let replacement = opts && 'replacement' in opts ? opts.replacement : null;
    if (replacement == null) dart.nullFailed(I[3], 122, 19, "replacement");
    this[frames$] = frames;
    this[replacement$] = replacement;
    if (!(frames != null)) dart.assertFailed(null, I[3], 123, 15, "frames != null");
    if (!(replacement != null)) dart.assertFailed(null, I[3], 124, 15, "replacement != null");
    assertions.RepetitiveStackFrameFilter.__proto__.new.call(this);
    ;
  }).prototype = assertions.RepetitiveStackFrameFilter.prototype;
  dart.addTypeTests(assertions.RepetitiveStackFrameFilter);
  dart.addTypeCaches(assertions.RepetitiveStackFrameFilter);
  dart.setMethodSignature(assertions.RepetitiveStackFrameFilter, () => ({
    __proto__: dart.getMethods(assertions.RepetitiveStackFrameFilter.__proto__),
    filter: dart.fnType(dart.void, [core.List$(stack_frame.StackFrame), core.List$(dart.nullable(core.String))]),
    [_matchesFrames]: dart.fnType(core.bool, [core.List$(stack_frame.StackFrame)])
  }));
  dart.setGetterSignature(assertions.RepetitiveStackFrameFilter, () => ({
    __proto__: dart.getGetters(assertions.RepetitiveStackFrameFilter.__proto__),
    numFrames: core.int,
    [_replacements]: core.List$(core.String)
  }));
  dart.setLibraryUri(assertions.RepetitiveStackFrameFilter, I[4]);
  dart.setFieldSignature(assertions.RepetitiveStackFrameFilter, () => ({
    __proto__: dart.getFields(assertions.RepetitiveStackFrameFilter.__proto__),
    frames: dart.finalFieldType(core.List$(assertions.PartialStackFrame)),
    replacement: dart.finalFieldType(core.String)
  }));
  assertions._ErrorDiagnostic = class _ErrorDiagnostic extends diagnostics$.DiagnosticsProperty$(core.List$(core.Object)) {
    get value() {
      return dart.nullCheck(super.value);
    }
    valueToString(opts) {
      let parentConfiguration = opts && 'parentConfiguration' in opts ? opts.parentConfiguration : null;
      return this.value[$join]("");
    }
  };
  (assertions._ErrorDiagnostic.new = function(message, opts) {
    if (message == null) dart.nullFailed(I[3], 169, 12, "message");
    let style = opts && 'style' in opts ? opts.style : C[19] || CT.C19;
    if (style == null) dart.nullFailed(I[3], 170, 26, "style");
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[3], 171, 21, "level");
    if (!(message != null)) dart.assertFailed(null, I[3], 172, 15, "message != null");
    assertions._ErrorDiagnostic.__proto__.new.call(this, null, T$.JSArrayOfObject().of([message]), {showName: false, showSeparator: false, defaultValue: null, style: style, level: level});
    ;
  }).prototype = assertions._ErrorDiagnostic.prototype;
  (assertions._ErrorDiagnostic._fromParts = function(messageParts, opts) {
    if (messageParts == null) dart.nullFailed(I[3], 209, 18, "messageParts");
    let style = opts && 'style' in opts ? opts.style : C[19] || CT.C19;
    if (style == null) dart.nullFailed(I[3], 210, 26, "style");
    let level = opts && 'level' in opts ? opts.level : C[5] || CT.C5;
    if (level == null) dart.nullFailed(I[3], 211, 21, "level");
    if (!(messageParts != null)) dart.assertFailed(null, I[3], 212, 15, "messageParts != null");
    assertions._ErrorDiagnostic.__proto__.new.call(this, null, messageParts, {showName: false, showSeparator: false, defaultValue: null, style: style, level: level});
    ;
  }).prototype = assertions._ErrorDiagnostic.prototype;
  dart.addTypeTests(assertions._ErrorDiagnostic);
  dart.addTypeCaches(assertions._ErrorDiagnostic);
  dart.setGetterSignature(assertions._ErrorDiagnostic, () => ({
    __proto__: dart.getGetters(assertions._ErrorDiagnostic.__proto__),
    value: core.List$(core.Object)
  }));
  dart.setLibraryUri(assertions._ErrorDiagnostic, I[4]);
  assertions.ErrorDescription = class ErrorDescription extends assertions._ErrorDiagnostic {};
  (assertions.ErrorDescription.new = function(message) {
    if (message == null) dart.nullFailed(I[3], 261, 27, "message");
    assertions.ErrorDescription.__proto__.new.call(this, message, {level: diagnostics$.DiagnosticLevel.info});
    ;
  }).prototype = assertions.ErrorDescription.prototype;
  (assertions.ErrorDescription._fromParts = function(messageParts) {
    if (messageParts == null) dart.nullFailed(I[3], 266, 44, "messageParts");
    assertions.ErrorDescription.__proto__._fromParts.call(this, messageParts, {level: diagnostics$.DiagnosticLevel.info});
    ;
  }).prototype = assertions.ErrorDescription.prototype;
  dart.addTypeTests(assertions.ErrorDescription);
  dart.addTypeCaches(assertions.ErrorDescription);
  dart.setLibraryUri(assertions.ErrorDescription, I[4]);
  assertions.ErrorSummary = class ErrorSummary extends assertions._ErrorDiagnostic {};
  (assertions.ErrorSummary.new = function(message) {
    if (message == null) dart.nullFailed(I[3], 300, 23, "message");
    assertions.ErrorSummary.__proto__.new.call(this, message, {level: diagnostics$.DiagnosticLevel.summary});
    ;
  }).prototype = assertions.ErrorSummary.prototype;
  (assertions.ErrorSummary._fromParts = function(messageParts) {
    if (messageParts == null) dart.nullFailed(I[3], 305, 40, "messageParts");
    assertions.ErrorSummary.__proto__._fromParts.call(this, messageParts, {level: diagnostics$.DiagnosticLevel.summary});
    ;
  }).prototype = assertions.ErrorSummary.prototype;
  dart.addTypeTests(assertions.ErrorSummary);
  dart.addTypeCaches(assertions.ErrorSummary);
  dart.setLibraryUri(assertions.ErrorSummary, I[4]);
  assertions.ErrorHint = class ErrorHint extends assertions._ErrorDiagnostic {};
  (assertions.ErrorHint.new = function(message) {
    if (message == null) dart.nullFailed(I[3], 335, 20, "message");
    assertions.ErrorHint.__proto__.new.call(this, message, {level: diagnostics$.DiagnosticLevel.hint});
    ;
  }).prototype = assertions.ErrorHint.prototype;
  (assertions.ErrorHint._fromParts = function(messageParts) {
    if (messageParts == null) dart.nullFailed(I[3], 340, 37, "messageParts");
    assertions.ErrorHint.__proto__._fromParts.call(this, messageParts, {level: diagnostics$.DiagnosticLevel.hint});
    ;
  }).prototype = assertions.ErrorHint.prototype;
  dart.addTypeTests(assertions.ErrorHint);
  dart.addTypeCaches(assertions.ErrorHint);
  dart.setLibraryUri(assertions.ErrorHint, I[4]);
  assertions.ErrorSpacer = class ErrorSpacer extends diagnostics$.DiagnosticsProperty$(dart.void) {};
  (assertions.ErrorSpacer.new = function() {
    assertions.ErrorSpacer.__proto__.new.call(this, "", null, {description: "", showName: false});
    ;
  }).prototype = assertions.ErrorSpacer.prototype;
  dart.addTypeTests(assertions.ErrorSpacer);
  dart.addTypeCaches(assertions.ErrorSpacer);
  dart.setLibraryUri(assertions.ErrorSpacer, I[4]);
  var exception$ = dart.privateName(assertions, "FlutterErrorDetails.exception");
  var stack$ = dart.privateName(assertions, "FlutterErrorDetails.stack");
  var library$ = dart.privateName(assertions, "FlutterErrorDetails.library");
  var context$ = dart.privateName(assertions, "FlutterErrorDetails.context");
  var stackFilter$ = dart.privateName(assertions, "FlutterErrorDetails.stackFilter");
  var informationCollector$ = dart.privateName(assertions, "FlutterErrorDetails.informationCollector");
  var silent$ = dart.privateName(assertions, "FlutterErrorDetails.silent");
  var _exceptionToDiagnosticable = dart.privateName(assertions, "_exceptionToDiagnosticable");
  const Object_Diagnosticable$36$ = class Object_Diagnosticable extends core.Object {};
  (Object_Diagnosticable$36$.new = function() {
  }).prototype = Object_Diagnosticable$36$.prototype;
  dart.applyMixin(Object_Diagnosticable$36$, diagnostics$.Diagnosticable);
  assertions.FlutterErrorDetails = class FlutterErrorDetails extends Object_Diagnosticable$36$ {
    get exception() {
      return this[exception$];
    }
    set exception(value) {
      super.exception = value;
    }
    get stack() {
      return this[stack$];
    }
    set stack(value) {
      super.stack = value;
    }
    get library() {
      return this[library$];
    }
    set library(value) {
      super.library = value;
    }
    get context() {
      return this[context$];
    }
    set context(value) {
      super.context = value;
    }
    get stackFilter() {
      return this[stackFilter$];
    }
    set stackFilter(value) {
      super.stackFilter = value;
    }
    get informationCollector() {
      return this[informationCollector$];
    }
    set informationCollector(value) {
      super.informationCollector = value;
    }
    get silent() {
      return this[silent$];
    }
    set silent(value) {
      super.silent = value;
    }
    copyWith(opts) {
      let t8, t8$, t8$0, t8$1, t8$2, t8$3, t8$4;
      let context = opts && 'context' in opts ? opts.context : null;
      let exception = opts && 'exception' in opts ? opts.exception : null;
      let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
      let library = opts && 'library' in opts ? opts.library : null;
      let silent = opts && 'silent' in opts ? opts.silent : null;
      let stack = opts && 'stack' in opts ? opts.stack : null;
      let stackFilter = opts && 'stackFilter' in opts ? opts.stackFilter : null;
      return new assertions.FlutterErrorDetails.new({context: (t8 = context, t8 == null ? this.context : t8), exception: (t8$ = exception, t8$ == null ? this.exception : t8$), informationCollector: (t8$0 = informationCollector, t8$0 == null ? this.informationCollector : t8$0), library: (t8$1 = library, t8$1 == null ? this.library : t8$1), silent: (t8$2 = silent, t8$2 == null ? this.silent : t8$2), stack: (t8$3 = stack, t8$3 == null ? this.stack : t8$3), stackFilter: (t8$4 = stackFilter, t8$4 == null ? this.stackFilter : t8$4)});
    }
    exceptionAsString() {
      let longMessage = null;
      if (core.AssertionError.is(this.exception)) {
        let message = core.AssertionError.as(this.exception).message;
        let fullMessage = dart.toString(this.exception);
        if (typeof message == 'string' && message != fullMessage) {
          if (fullMessage.length > message.length) {
            let position = fullMessage[$lastIndexOf](message);
            if (position === fullMessage.length - message.length && position > 2 && fullMessage[$substring](position - 2, position) === ": ") {
              let body = fullMessage[$substring](0, position - 2);
              let splitPoint = body[$indexOf](" Failed assertion:");
              if (splitPoint >= 0) {
                body = body[$substring](0, splitPoint) + "\n" + body[$substring](splitPoint + 1);
              }
              longMessage = message[$trimRight]() + "\n" + body;
            }
          }
        }
        longMessage == null ? longMessage = fullMessage : null;
      } else if (typeof this.exception == 'string') {
        longMessage = core.String.as(this.exception);
      } else if (core.Error.is(this.exception) || core.Exception.is(this.exception)) {
        longMessage = dart.toString(this.exception);
      } else {
        longMessage = "  " + dart.str(dart.toString(this.exception));
      }
      longMessage = longMessage[$trimRight]();
      if (longMessage[$isEmpty]) longMessage = "  <no message available>";
      return longMessage;
    }
    [_exceptionToDiagnosticable]() {
      let exception = this.exception;
      if (assertions.FlutterError.is(exception)) {
        return exception;
      }
      if (core.AssertionError.is(exception) && assertions.FlutterError.is(exception.message)) {
        return assertions.FlutterError.as(dart.nullCheck(exception.message));
      }
      return null;
    }
    get summary() {
      let t8;
      const formatException = () => {
        return this.exceptionAsString()[$split]("\n")[$_get](0)[$trimLeft]();
      };
      dart.fn(formatException, T$.VoidToString());
      if (false) {
        return diagnostics$.DiagnosticsNode.message(formatException());
      }
      let diagnosticable = this[_exceptionToDiagnosticable]();
      let summary = null;
      if (diagnosticable != null) {
        let builder = new diagnostics$.DiagnosticPropertiesBuilder.new();
        this.debugFillProperties(builder);
        summary = builder.properties[$cast](T$.DiagnosticsNodeN())[$firstWhere](dart.fn(node => dart.nullCheck(node).level == diagnostics$.DiagnosticLevel.summary, T$.DiagnosticsNodeNTobool()), {orElse: dart.fn(() => null, T$.VoidToNull())});
      }
      t8 = summary;
      return t8 == null ? new assertions.ErrorSummary.new(formatException()) : t8;
    }
    debugFillProperties(properties) {
      if (properties == null) dart.nullFailed(I[3], 623, 56, "properties");
      super.debugFillProperties(properties);
      let verb = new assertions.ErrorDescription.new("thrown" + dart.str(this.context != null ? new assertions.ErrorDescription.new(" " + dart.str(this.context)) : ""));
      let diagnosticable = this[_exceptionToDiagnosticable]();
      if (core.NullThrownError.is(this.exception)) {
        properties.add(new assertions.ErrorDescription.new("The null value was " + dart.str(verb) + "."));
      } else if (typeof this.exception == 'number') {
        properties.add(new assertions.ErrorDescription.new("The number " + dart.str(this.exception) + " was " + dart.str(verb) + "."));
      } else {
        let errorName = null;
        if (core.AssertionError.is(this.exception)) {
          errorName = new assertions.ErrorDescription.new("assertion");
        } else if (typeof this.exception == 'string') {
          errorName = new assertions.ErrorDescription.new("message");
        } else if (core.Error.is(this.exception) || core.Exception.is(this.exception)) {
          errorName = new assertions.ErrorDescription.new(dart.str(dart.runtimeType(this.exception)));
        } else {
          errorName = new assertions.ErrorDescription.new(dart.str(dart.runtimeType(this.exception)) + " object");
        }
        properties.add(new assertions.ErrorDescription.new("The following " + dart.str(errorName) + " was " + dart.str(verb) + ":"));
        if (diagnosticable != null) {
          diagnosticable.debugFillProperties(properties);
        } else {
          let prefix = dart.str(dart.runtimeType(this.exception)) + ": ";
          let message = this.exceptionAsString();
          if (message[$startsWith](prefix)) message = message[$substring](prefix.length);
          properties.add(new assertions.ErrorSummary.new(message));
        }
      }
      if (this.stack != null) {
        if (core.AssertionError.is(this.exception) && diagnosticable == null) {
          let stackFrames = stack_frame.StackFrame.fromStackTrace(assertions.FlutterError.demangleStackTrace(dart.nullCheck(this.stack)))[$skipWhile](dart.fn(frame => {
            if (frame == null) dart.nullFailed(I[3], 666, 79, "frame");
            return frame.packageScheme === "dart";
          }, T$.StackFrameTobool()))[$toList]();
          let ourFault = dart.notNull(stackFrames[$length]) >= 2 && stackFrames[$_get](0).package === "flutter" && stackFrames[$_get](1).package === "flutter";
          if (ourFault) {
            properties.add(new assertions.ErrorSpacer.new());
            properties.add(new assertions.ErrorHint.new("Either the assertion indicates an error in the framework itself, or we should " + "provide substantially more information in this error message to help you determine " + "and fix the underlying cause.\n" + "In either case, please report this assertion by filing a bug on GitHub:\n" + "  https://github.com/flutter/flutter/issues/new?template=2_bug.md"));
          }
        }
        properties.add(new assertions.ErrorSpacer.new());
        properties.add(new assertions.DiagnosticsStackTrace.new("When the exception was thrown, this was the stack", this.stack, {stackFilter: this.stackFilter}));
      }
      if (this.informationCollector != null) {
        properties.add(new assertions.ErrorSpacer.new());
        dart.nullCheck(this.informationCollector)()[$forEach](dart.bind(properties, 'add'));
      }
    }
    toStringShort() {
      return this.library != null ? "Exception caught by " + dart.str(this.library) : "Exception caught";
    }
    toString(opts) {
      let minLevel = opts && 'minLevel' in opts ? opts.minLevel : C[5] || CT.C5;
      if (minLevel == null) dart.nullFailed(I[3], 697, 36, "minLevel");
      return this.toDiagnosticsNode({style: diagnostics$.DiagnosticsTreeStyle.error}).toStringDeep({minLevel: minLevel});
    }
    toDiagnosticsNode(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let style = opts && 'style' in opts ? opts.style : null;
      return new assertions._FlutterErrorDetailsNode.new({name: name, value: this, style: style});
    }
  };
  (assertions.FlutterErrorDetails.new = function(opts) {
    let exception = opts && 'exception' in opts ? opts.exception : null;
    if (exception == null) dart.nullFailed(I[3], 393, 19, "exception");
    let stack = opts && 'stack' in opts ? opts.stack : null;
    let library = opts && 'library' in opts ? opts.library : "Flutter framework";
    let context = opts && 'context' in opts ? opts.context : null;
    let stackFilter = opts && 'stackFilter' in opts ? opts.stackFilter : null;
    let informationCollector = opts && 'informationCollector' in opts ? opts.informationCollector : null;
    let silent = opts && 'silent' in opts ? opts.silent : false;
    if (silent == null) dart.nullFailed(I[3], 399, 10, "silent");
    this[exception$] = exception;
    this[stack$] = stack;
    this[library$] = library;
    this[context$] = context;
    this[stackFilter$] = stackFilter;
    this[informationCollector$] = informationCollector;
    this[silent$] = silent;
    if (!(exception != null)) dart.assertFailed(null, I[3], 400, 15, "exception != null");
    ;
  }).prototype = assertions.FlutterErrorDetails.prototype;
  dart.addTypeTests(assertions.FlutterErrorDetails);
  dart.addTypeCaches(assertions.FlutterErrorDetails);
  dart.setMethodSignature(assertions.FlutterErrorDetails, () => ({
    __proto__: dart.getMethods(assertions.FlutterErrorDetails.__proto__),
    copyWith: dart.fnType(assertions.FlutterErrorDetails, [], {context: dart.nullable(diagnostics$.DiagnosticsNode), exception: dart.nullable(core.Object), informationCollector: dart.nullable(dart.fnType(core.Iterable$(diagnostics$.DiagnosticsNode), [])), library: dart.nullable(core.String), silent: dart.nullable(core.bool), stack: dart.nullable(core.StackTrace), stackFilter: dart.nullable(dart.fnType(core.Iterable$(core.String), [core.Iterable$(core.String)]))}, {}),
    exceptionAsString: dart.fnType(core.String, []),
    [_exceptionToDiagnosticable]: dart.fnType(dart.nullable(diagnostics$.Diagnosticable), [])
  }));
  dart.setGetterSignature(assertions.FlutterErrorDetails, () => ({
    __proto__: dart.getGetters(assertions.FlutterErrorDetails.__proto__),
    summary: diagnostics$.DiagnosticsNode
  }));
  dart.setLibraryUri(assertions.FlutterErrorDetails, I[4]);
  dart.setFieldSignature(assertions.FlutterErrorDetails, () => ({
    __proto__: dart.getFields(assertions.FlutterErrorDetails.__proto__),
    exception: dart.finalFieldType(core.Object),
    stack: dart.finalFieldType(dart.nullable(core.StackTrace)),
    library: dart.finalFieldType(dart.nullable(core.String)),
    context: dart.finalFieldType(dart.nullable(diagnostics$.DiagnosticsNode)),
    stackFilter: dart.finalFieldType(dart.nullable(dart.fnType(core.Iterable$(core.String), [core.Iterable$(core.String)]))),
    informationCollector: dart.finalFieldType(dart.nullable(dart.fnType(core.Iterable$(diagnostics$.DiagnosticsNode), []))),
    silent: dart.finalFieldType(core.bool)
  }));
  dart.defineExtensionMethods(assertions.FlutterErrorDetails, ['toString']);
  dart.defineLazy(assertions.FlutterErrorDetails, {
    /*assertions.FlutterErrorDetails.propertiesTransformers*/get propertiesTransformers() {
      return T$.JSArrayOfIterableOfDiagnosticsNodeToIterableOfDiagnosticsNode().of([]);
    }
  }, false);
  var diagnostics$0 = dart.privateName(assertions, "FlutterError.diagnostics");
  const Error_DiagnosticableTreeMixin$36 = class Error_DiagnosticableTreeMixin extends core.Error {};
  (Error_DiagnosticableTreeMixin$36.new = function() {
    Error_DiagnosticableTreeMixin$36.__proto__.new.call(this);
  }).prototype = Error_DiagnosticableTreeMixin$36.prototype;
  dart.applyMixin(Error_DiagnosticableTreeMixin$36, diagnostics$.DiagnosticableTreeMixin);
  assertions.FlutterError = class FlutterError extends Error_DiagnosticableTreeMixin$36 {
    get diagnostics() {
      return this[diagnostics$0];
    }
    set diagnostics(value) {
      super.diagnostics = value;
    }
    static new(message) {
      if (message == null) dart.nullFailed(I[3], 740, 31, "message");
      let lines = message[$split]("\n");
      return new assertions.FlutterError.fromParts((() => {
        let t8 = T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new(lines[$first])]);
        t8[$addAll](lines[$skip](1)[$map](diagnostics$.DiagnosticsNode, dart.fn(line => {
          if (line == null) dart.nullFailed(I[3], 744, 53, "line");
          return new assertions.ErrorDescription.new(line);
        }, T$.StringToErrorDescription())));
        return t8;
      })());
    }
    get message() {
      return this.toString();
    }
    static resetErrorCount() {
      assertions.FlutterError._errorCount = 0;
    }
    static dumpErrorToConsole(details, opts) {
      if (details == null) dart.nullFailed(I[3], 944, 54, "details");
      let forceReport = opts && 'forceReport' in opts ? opts.forceReport : false;
      if (forceReport == null) dart.nullFailed(I[3],